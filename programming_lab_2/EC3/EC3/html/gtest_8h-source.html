<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>EC3: Escritorio/EC3/src/gtest/gtest.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.2 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li class="current"><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul>
</div>
<h1>Escritorio/EC3/src/gtest/gtest.h</h1><a href="gtest_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2005, Google Inc.</span>
<a name="l00002"></a>00002 <span class="comment">// All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment">// modification, are permitted provided that the following conditions are</span>
<a name="l00006"></a>00006 <span class="comment">// met:</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">//     * Redistributions of source code must retain the above copyright</span>
<a name="l00009"></a>00009 <span class="comment">// notice, this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment">//     * Redistributions in binary form must reproduce the above</span>
<a name="l00011"></a>00011 <span class="comment">// copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00012"></a>00012 <span class="comment">// in the documentation and/or other materials provided with the</span>
<a name="l00013"></a>00013 <span class="comment">// distribution.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Neither the name of Google Inc. nor the names of its</span>
<a name="l00015"></a>00015 <span class="comment">// contributors may be used to endorse or promote products derived from</span>
<a name="l00016"></a>00016 <span class="comment">// this software without specific prior written permission.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00019"></a>00019 <span class="comment">// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00020"></a>00020 <span class="comment">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00021"></a>00021 <span class="comment">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00022"></a>00022 <span class="comment">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00023"></a>00023 <span class="comment">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00028"></a>00028 <span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">// Author: wan@google.com (Zhanyong Wan)</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">// The Google C++ Testing Framework (Google Test)</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00034"></a>00034 <span class="comment">// This header file defines the public API for Google Test.  It should be</span>
<a name="l00035"></a>00035 <span class="comment">// included by any test program that uses Google Test.</span>
<a name="l00036"></a>00036 <span class="comment">//</span>
<a name="l00037"></a>00037 <span class="comment">// IMPORTANT NOTE: Due to limitation of the C++ language, we have to</span>
<a name="l00038"></a>00038 <span class="comment">// leave some internal implementation details in this header file.</span>
<a name="l00039"></a>00039 <span class="comment">// They are clearly marked by comments like this:</span>
<a name="l00040"></a>00040 <span class="comment">//</span>
<a name="l00041"></a>00041 <span class="comment">//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00042"></a>00042 <span class="comment">//</span>
<a name="l00043"></a>00043 <span class="comment">// Such code is NOT meant to be used by a user directly, and is subject</span>
<a name="l00044"></a>00044 <span class="comment">// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user</span>
<a name="l00045"></a>00045 <span class="comment">// program!</span>
<a name="l00046"></a>00046 <span class="comment">//</span>
<a name="l00047"></a>00047 <span class="comment">// Acknowledgment: Google Test borrowed the idea of automatic test</span>
<a name="l00048"></a>00048 <span class="comment">// registration from Barthelemy Dagenais' (barthelemy@prologique.com)</span>
<a name="l00049"></a>00049 <span class="comment">// easyUnit framework.</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#ifndef GTEST_INCLUDE_GTEST_GTEST_H_</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define GTEST_INCLUDE_GTEST_GTEST_H_</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="comment">// The following platform macros are used throughout Google Test:</span>
<a name="l00055"></a>00055 <span class="comment">//   _WIN32_WCE      Windows CE     (set in project files)</span>
<a name="l00056"></a>00056 <span class="comment">//</span>
<a name="l00057"></a>00057 <span class="comment">// Note that even though _MSC_VER and _WIN32_WCE really indicate a compiler</span>
<a name="l00058"></a>00058 <span class="comment">// and a Win32 implementation, respectively, we use them to indicate the</span>
<a name="l00059"></a>00059 <span class="comment">// combination of compiler - Win 32 API - C library, since the code currently</span>
<a name="l00060"></a>00060 <span class="comment">// only supports:</span>
<a name="l00061"></a>00061 <span class="comment">// Windows proper with Visual C++ and MS C library (_MSC_VER &amp;&amp; !_WIN32_WCE) and</span>
<a name="l00062"></a>00062 <span class="comment">// Windows Mobile with Visual C++ and no C library (_WIN32_WCE).</span>
<a name="l00063"></a>00063 
<a name="l00064"></a>00064 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &lt;<a class="code" href="gtest-internal_8h.html">gtest/internal/gtest-internal.h</a>&gt;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &lt;<a class="code" href="gtest-string_8h.html">gtest/internal/gtest-string.h</a>&gt;</span>
<a name="l00067"></a>00067 <span class="preprocessor">#include &lt;<a class="code" href="gtest-death-test_8h.html">gtest/gtest-death-test.h</a>&gt;</span>
<a name="l00068"></a>00068 <span class="preprocessor">#include &lt;<a class="code" href="gtest-message_8h.html">gtest/gtest-message.h</a>&gt;</span>
<a name="l00069"></a>00069 <span class="preprocessor">#include &lt;<a class="code" href="gtest-param-test_8h.html">gtest/gtest-param-test.h</a>&gt;</span>
<a name="l00070"></a>00070 <span class="preprocessor">#include &lt;<a class="code" href="gtest__prod_8h.html">gtest/gtest_prod.h</a>&gt;</span>
<a name="l00071"></a>00071 <span class="preprocessor">#include &lt;<a class="code" href="gtest-test-part_8h.html">gtest/gtest-test-part.h</a>&gt;</span>
<a name="l00072"></a>00072 <span class="preprocessor">#include &lt;<a class="code" href="gtest-typed-test_8h.html">gtest/gtest-typed-test.h</a>&gt;</span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="comment">// Depending on the platform, different string classes are available.</span>
<a name="l00075"></a>00075 <span class="comment">// On Windows, ::std::string compiles only when exceptions are</span>
<a name="l00076"></a>00076 <span class="comment">// enabled.  On Linux, in addition to ::std::string, Google also makes</span>
<a name="l00077"></a>00077 <span class="comment">// use of class ::string, which has the same interface as</span>
<a name="l00078"></a>00078 <span class="comment">// ::std::string, but has a different implementation.</span>
<a name="l00079"></a>00079 <span class="comment">//</span>
<a name="l00080"></a>00080 <span class="comment">// The user can tell us whether ::std::string is available in his</span>
<a name="l00081"></a>00081 <span class="comment">// environment by defining the macro GTEST_HAS_STD_STRING to either 1</span>
<a name="l00082"></a>00082 <span class="comment">// or 0 on the compiler command line.  He can also define</span>
<a name="l00083"></a>00083 <span class="comment">// GTEST_HAS_GLOBAL_STRING to 1 to indicate that ::string is available</span>
<a name="l00084"></a>00084 <span class="comment">// AND is a distinct type to ::std::string, or define it to 0 to</span>
<a name="l00085"></a>00085 <span class="comment">// indicate otherwise.</span>
<a name="l00086"></a>00086 <span class="comment">//</span>
<a name="l00087"></a>00087 <span class="comment">// If the user's ::std::string and ::string are the same class due to</span>
<a name="l00088"></a>00088 <span class="comment">// aliasing, he should define GTEST_HAS_STD_STRING to 1 and</span>
<a name="l00089"></a>00089 <span class="comment">// GTEST_HAS_GLOBAL_STRING to 0.</span>
<a name="l00090"></a>00090 <span class="comment">//</span>
<a name="l00091"></a>00091 <span class="comment">// If the user doesn't define GTEST_HAS_STD_STRING and/or</span>
<a name="l00092"></a>00092 <span class="comment">// GTEST_HAS_GLOBAL_STRING, they are defined heuristically.</span>
<a name="l00093"></a>00093 
<a name="l00094"></a>00094 <span class="keyword">namespace </span>testing {
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 <span class="comment">// The upper limit for valid stack trace depths.</span>
<a name="l00097"></a><a class="code" href="namespacetesting.html#9cac1f5e8a177c033ab6b61c230dc0b8">00097</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesting.html#9cac1f5e8a177c033ab6b61c230dc0b8">kMaxStackTraceDepth</a> = 100;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="comment">// This flag specifies the maximum number of stack frames to be</span>
<a name="l00100"></a>00100 <span class="comment">// printed in a failure message.</span>
<a name="l00101"></a>00101 <a class="code" href="namespacetesting.html#984f1c280ed67aa6fba294883a6fb0c9">GTEST_DECLARE_int32_</a>(stack_trace_depth);
<a name="l00102"></a>00102 
<a name="l00103"></a>00103 <span class="comment">// This flag controls whether Google Test includes Google Test internal</span>
<a name="l00104"></a>00104 <span class="comment">// stack frames in failure stack traces.</span>
<a name="l00105"></a>00105 <a class="code" href="namespacetesting.html#d442d8de4238b60c7e5971ff926a433b">GTEST_DECLARE_bool_</a>(show_internal_stack_frames);
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keyword">namespace </span>internal {
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 <span class="keyword">class </span>GTestFlagSaver;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">// Converts a streamable value to a String.  A NULL pointer is</span>
<a name="l00112"></a>00112 <span class="comment">// converted to "(null)".  When the input value is a ::string,</span>
<a name="l00113"></a>00113 <span class="comment">// ::std::string, ::wstring, or ::std::wstring object, each NUL</span>
<a name="l00114"></a>00114 <span class="comment">// character in it is replaced with "\\0".</span>
<a name="l00115"></a>00115 <span class="comment">// Declared in gtest-internal.h but defined here, so that it has access</span>
<a name="l00116"></a>00116 <span class="comment">// to the definition of the Message class, required by the ARM</span>
<a name="l00117"></a>00117 <span class="comment">// compiler.</span>
<a name="l00118"></a>00118 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00119"></a><a class="code" href="namespacetesting_1_1internal.html#0406702dd38ef95c6b71991da985c6a5">00119</a> <a class="code" href="classtesting_1_1internal_1_1String.html">String</a> <a class="code" href="namespacetesting_1_1internal.html#0406702dd38ef95c6b71991da985c6a5">StreamableToString</a>(<span class="keyword">const</span> T&amp; streamable) {
<a name="l00120"></a>00120   <span class="keywordflow">return</span> (<a class="code" href="classtesting_1_1Message.html">Message</a>() &lt;&lt; streamable).GetString();
<a name="l00121"></a>00121 }
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 }  <span class="comment">// namespace internal</span>
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">// A class for indicating whether an assertion was successful.  When</span>
<a name="l00126"></a>00126 <span class="comment">// the assertion wasn't successful, the AssertionResult object</span>
<a name="l00127"></a>00127 <span class="comment">// remembers a non-empty message that described how it failed.</span>
<a name="l00128"></a>00128 <span class="comment">//</span>
<a name="l00129"></a>00129 <span class="comment">// This class is useful for defining predicate-format functions to be</span>
<a name="l00130"></a>00130 <span class="comment">// used with predicate assertions (ASSERT_PRED_FORMAT*, etc).</span>
<a name="l00131"></a>00131 <span class="comment">//</span>
<a name="l00132"></a>00132 <span class="comment">// The constructor of AssertionResult is private.  To create an</span>
<a name="l00133"></a>00133 <span class="comment">// instance of this class, use one of the factory functions</span>
<a name="l00134"></a>00134 <span class="comment">// (AssertionSuccess() and AssertionFailure()).</span>
<a name="l00135"></a>00135 <span class="comment">//</span>
<a name="l00136"></a>00136 <span class="comment">// For example, in order to be able to write:</span>
<a name="l00137"></a>00137 <span class="comment">//</span>
<a name="l00138"></a>00138 <span class="comment">//   // Verifies that Foo() returns an even number.</span>
<a name="l00139"></a>00139 <span class="comment">//   EXPECT_PRED_FORMAT1(IsEven, Foo());</span>
<a name="l00140"></a>00140 <span class="comment">//</span>
<a name="l00141"></a>00141 <span class="comment">// you just need to define:</span>
<a name="l00142"></a>00142 <span class="comment">//</span>
<a name="l00143"></a>00143 <span class="comment">//   testing::AssertionResult IsEven(const char* expr, int n) {</span>
<a name="l00144"></a>00144 <span class="comment">//     if ((n % 2) == 0) return testing::AssertionSuccess();</span>
<a name="l00145"></a>00145 <span class="comment">//</span>
<a name="l00146"></a>00146 <span class="comment">//     Message msg;</span>
<a name="l00147"></a>00147 <span class="comment">//     msg &lt;&lt; "Expected: " &lt;&lt; expr &lt;&lt; " is even\n"</span>
<a name="l00148"></a>00148 <span class="comment">//         &lt;&lt; "  Actual: it's " &lt;&lt; n;</span>
<a name="l00149"></a>00149 <span class="comment">//     return testing::AssertionFailure(msg);</span>
<a name="l00150"></a>00150 <span class="comment">//   }</span>
<a name="l00151"></a>00151 <span class="comment">//</span>
<a name="l00152"></a>00152 <span class="comment">// If Foo() returns 5, you will see the following message:</span>
<a name="l00153"></a>00153 <span class="comment">//</span>
<a name="l00154"></a>00154 <span class="comment">//   Expected: Foo() is even</span>
<a name="l00155"></a>00155 <span class="comment">//     Actual: it's 5</span>
<a name="l00156"></a><a class="code" href="classtesting_1_1AssertionResult.html">00156</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> {
<a name="l00157"></a>00157  <span class="keyword">public</span>:
<a name="l00158"></a>00158   <span class="comment">// Declares factory functions for making successful and failed</span>
<a name="l00159"></a>00159   <span class="comment">// assertion results as friends.</span>
<a name="l00160"></a>00160   <span class="keyword">friend</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="classtesting_1_1AssertionResult.html#267aaa36088ac85912d7419f8fe0341f">AssertionSuccess</a>();
<a name="l00161"></a>00161   <span class="keyword">friend</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="classtesting_1_1AssertionResult.html#985d9ec766c8ba052e1608c35406e355">AssertionFailure</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Message.html">Message</a>&amp;);
<a name="l00162"></a>00162 
<a name="l00163"></a>00163   <span class="comment">// Returns true iff the assertion succeeded.</span>
<a name="l00164"></a><a class="code" href="classtesting_1_1AssertionResult.html#ab619647c071b6e2cca9cd1efa2d4bd6">00164</a>   <a class="code" href="classtesting_1_1AssertionResult.html#ab619647c071b6e2cca9cd1efa2d4bd6">operator bool</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1AssertionResult.html#15bb10ebc15892d1ae7d9cd4b1d61901">failure_message_</a>.<a class="code" href="classtesting_1_1internal_1_1String.html#88be98337a01ae18eb6c3f084288e0a5">c_str</a>() == NULL; }  <span class="comment">// NOLINT</span>
<a name="l00165"></a>00165 
<a name="l00166"></a>00166   <span class="comment">// Returns the assertion's failure message.</span>
<a name="l00167"></a><a class="code" href="classtesting_1_1AssertionResult.html#cea6bc1ad95e884256239f66b9bcc932">00167</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1AssertionResult.html#cea6bc1ad95e884256239f66b9bcc932">failure_message</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1AssertionResult.html#15bb10ebc15892d1ae7d9cd4b1d61901">failure_message_</a>.<a class="code" href="classtesting_1_1internal_1_1String.html#88be98337a01ae18eb6c3f084288e0a5">c_str</a>(); }
<a name="l00168"></a>00168 
<a name="l00169"></a>00169  <span class="keyword">private</span>:
<a name="l00170"></a>00170   <span class="comment">// The default constructor.  It is used when the assertion succeeded.</span>
<a name="l00171"></a><a class="code" href="classtesting_1_1AssertionResult.html#1f2e093a8aedb6f4939d10e3ac6df302">00171</a>   <a class="code" href="classtesting_1_1AssertionResult.html#1f2e093a8aedb6f4939d10e3ac6df302">AssertionResult</a>() {}
<a name="l00172"></a>00172 
<a name="l00173"></a>00173   <span class="comment">// The constructor used when the assertion failed.</span>
<a name="l00174"></a>00174   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1AssertionResult.html#1f2e093a8aedb6f4939d10e3ac6df302">AssertionResult</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1String.html">internal::String</a>&amp; <a class="code" href="classtesting_1_1AssertionResult.html#cea6bc1ad95e884256239f66b9bcc932">failure_message</a>);
<a name="l00175"></a>00175 
<a name="l00176"></a>00176   <span class="comment">// Stores the assertion's failure message.</span>
<a name="l00177"></a><a class="code" href="classtesting_1_1AssertionResult.html#15bb10ebc15892d1ae7d9cd4b1d61901">00177</a>   <a class="code" href="classtesting_1_1internal_1_1String.html">internal::String</a> <a class="code" href="classtesting_1_1AssertionResult.html#15bb10ebc15892d1ae7d9cd4b1d61901">failure_message_</a>;
<a name="l00178"></a>00178 };
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 <span class="comment">// Makes a successful assertion result.</span>
<a name="l00181"></a>00181 <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting.html#b729c66d933de254c89cddb7f3c71ec4">AssertionSuccess</a>();
<a name="l00182"></a>00182 
<a name="l00183"></a>00183 <span class="comment">// Makes a failed assertion result with the given failure message.</span>
<a name="l00184"></a>00184 <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting.html#07666fd50196e9727d0731c056fa1957">AssertionFailure</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Message.html">Message</a>&amp; msg);
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// The abstract class that all tests inherit from.</span>
<a name="l00187"></a>00187 <span class="comment">//</span>
<a name="l00188"></a>00188 <span class="comment">// In Google Test, a unit test program contains one or many TestCases, and</span>
<a name="l00189"></a>00189 <span class="comment">// each TestCase contains one or many Tests.</span>
<a name="l00190"></a>00190 <span class="comment">//</span>
<a name="l00191"></a>00191 <span class="comment">// When you define a test using the TEST macro, you don't need to</span>
<a name="l00192"></a>00192 <span class="comment">// explicitly derive from Test - the TEST macro automatically does</span>
<a name="l00193"></a>00193 <span class="comment">// this for you.</span>
<a name="l00194"></a>00194 <span class="comment">//</span>
<a name="l00195"></a>00195 <span class="comment">// The only time you derive from Test is when defining a test fixture</span>
<a name="l00196"></a>00196 <span class="comment">// to be used a TEST_F.  For example:</span>
<a name="l00197"></a>00197 <span class="comment">//</span>
<a name="l00198"></a>00198 <span class="comment">//   class FooTest : public testing::Test {</span>
<a name="l00199"></a>00199 <span class="comment">//    protected:</span>
<a name="l00200"></a>00200 <span class="comment">//     virtual void SetUp() { ... }</span>
<a name="l00201"></a>00201 <span class="comment">//     virtual void TearDown() { ... }</span>
<a name="l00202"></a>00202 <span class="comment">//     ...</span>
<a name="l00203"></a>00203 <span class="comment">//   };</span>
<a name="l00204"></a>00204 <span class="comment">//</span>
<a name="l00205"></a>00205 <span class="comment">//   TEST_F(FooTest, Bar) { ... }</span>
<a name="l00206"></a>00206 <span class="comment">//   TEST_F(FooTest, Baz) { ... }</span>
<a name="l00207"></a>00207 <span class="comment">//</span>
<a name="l00208"></a>00208 <span class="comment">// Test is not copyable.</span>
<a name="l00209"></a><a class="code" href="classtesting_1_1Test.html">00209</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1Test.html">Test</a> {
<a name="l00210"></a>00210  <span class="keyword">public</span>:
<a name="l00211"></a><a class="code" href="classtesting_1_1Test.html#5aa7b30faff2d57475f7e9eea1bc8eaa">00211</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1Test.html#5aa7b30faff2d57475f7e9eea1bc8eaa">internal::TestInfoImpl</a>;
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="comment">// Defines types for pointers to functions that set up and tear down</span>
<a name="l00214"></a>00214   <span class="comment">// a test case.</span>
<a name="l00215"></a><a class="code" href="classtesting_1_1Test.html#ccbfb9e722f1f1fef94248d056ed918c">00215</a>   <span class="keyword">typedef</span> <a class="code" href="namespacetesting_1_1internal.html#1b8518e7b2cdc051b4379b923be61d5d">internal::SetUpTestCaseFunc</a> <a class="code" href="namespacetesting_1_1internal.html#1b8518e7b2cdc051b4379b923be61d5d">SetUpTestCaseFunc</a>;
<a name="l00216"></a><a class="code" href="classtesting_1_1Test.html#b4fbbeba80a377c0ab2ea2793c2a2a33">00216</a>   <span class="keyword">typedef</span> <a class="code" href="namespacetesting_1_1internal.html#b87631eabafc70771cf3fb20be8b3adc">internal::TearDownTestCaseFunc</a> <a class="code" href="namespacetesting_1_1internal.html#b87631eabafc70771cf3fb20be8b3adc">TearDownTestCaseFunc</a>;
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="comment">// The d'tor is virtual as we intend to inherit from Test.</span>
<a name="l00219"></a>00219   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1Test.html#fb788db3d734171957dc11ebe5f1a9cb">~Test</a>();
<a name="l00220"></a>00220 
<a name="l00221"></a>00221   <span class="comment">// Sets up the stuff shared by all tests in this test case.</span>
<a name="l00222"></a>00222   <span class="comment">//</span>
<a name="l00223"></a>00223   <span class="comment">// Google Test will call Foo::SetUpTestCase() before running the first</span>
<a name="l00224"></a>00224   <span class="comment">// test in test case Foo.  Hence a sub-class can define its own</span>
<a name="l00225"></a>00225   <span class="comment">// SetUpTestCase() method to shadow the one defined in the super</span>
<a name="l00226"></a>00226   <span class="comment">// class.</span>
<a name="l00227"></a><a class="code" href="classtesting_1_1Test.html#23c50ad7f4dd7c23eb7bead09ca1e25b">00227</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#23c50ad7f4dd7c23eb7bead09ca1e25b">SetUpTestCase</a>() {}
<a name="l00228"></a>00228 
<a name="l00229"></a>00229   <span class="comment">// Tears down the stuff shared by all tests in this test case.</span>
<a name="l00230"></a>00230   <span class="comment">//</span>
<a name="l00231"></a>00231   <span class="comment">// Google Test will call Foo::TearDownTestCase() after running the last</span>
<a name="l00232"></a>00232   <span class="comment">// test in test case Foo.  Hence a sub-class can define its own</span>
<a name="l00233"></a>00233   <span class="comment">// TearDownTestCase() method to shadow the one defined in the super</span>
<a name="l00234"></a>00234   <span class="comment">// class.</span>
<a name="l00235"></a><a class="code" href="classtesting_1_1Test.html#a9a9d7e19e41c660b6880d2d25918726">00235</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#a9a9d7e19e41c660b6880d2d25918726">TearDownTestCase</a>() {}
<a name="l00236"></a>00236 
<a name="l00237"></a>00237   <span class="comment">// Returns true iff the current test has a fatal failure.</span>
<a name="l00238"></a>00238   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1Test.html#765821feda4da8debf420af85aa597b5">HasFatalFailure</a>();
<a name="l00239"></a>00239 
<a name="l00240"></a>00240   <span class="comment">// Logs a property for the current test.  Only the last value for a given</span>
<a name="l00241"></a>00241   <span class="comment">// key is remembered.</span>
<a name="l00242"></a>00242   <span class="comment">// These are public static so they can be called from utility functions</span>
<a name="l00243"></a>00243   <span class="comment">// that are not members of the test fixture.</span>
<a name="l00244"></a>00244   <span class="comment">// The arguments are const char* instead strings, as Google Test is used</span>
<a name="l00245"></a>00245   <span class="comment">// on platforms where string doesn't compile.</span>
<a name="l00246"></a>00246   <span class="comment">//</span>
<a name="l00247"></a>00247   <span class="comment">// Note that a driving consideration for these RecordProperty methods</span>
<a name="l00248"></a>00248   <span class="comment">// was to produce xml output suited to the Greenspan charting utility,</span>
<a name="l00249"></a>00249   <span class="comment">// which at present will only chart values that fit in a 32-bit int. It</span>
<a name="l00250"></a>00250   <span class="comment">// is the user's responsibility to restrict their values to 32-bit ints</span>
<a name="l00251"></a>00251   <span class="comment">// if they intend them to be used with Greenspan.</span>
<a name="l00252"></a>00252   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#91032b7a73c1881bbab4db263fa44447">RecordProperty</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">char</span>* value);
<a name="l00253"></a>00253   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#91032b7a73c1881bbab4db263fa44447">RecordProperty</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keywordtype">int</span> value);
<a name="l00254"></a>00254 
<a name="l00255"></a>00255  <span class="keyword">protected</span>:
<a name="l00256"></a>00256   <span class="comment">// Creates a Test object.</span>
<a name="l00257"></a>00257   <a class="code" href="classtesting_1_1Test.html#43ef73098874414f6c9fbfa32f90ba95">Test</a>();
<a name="l00258"></a>00258 
<a name="l00259"></a>00259   <span class="comment">// Sets up the test fixture.</span>
<a name="l00260"></a>00260   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#aa64e7ad495ea976b98f97a5f3738c35">SetUp</a>();
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <span class="comment">// Tears down the test fixture.</span>
<a name="l00263"></a>00263   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#1f5480b7d2c1067f7bba77a8993cf12f">TearDown</a>();
<a name="l00264"></a>00264 
<a name="l00265"></a>00265  <span class="keyword">private</span>:
<a name="l00266"></a>00266   <span class="comment">// Returns true iff the current test has the same fixture class as</span>
<a name="l00267"></a>00267   <span class="comment">// the first test in the current test case.</span>
<a name="l00268"></a>00268   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1Test.html#b3e94213b33ebf1443b00c11b777ef98">HasSameFixtureClass</a>();
<a name="l00269"></a>00269 
<a name="l00270"></a>00270   <span class="comment">// Runs the test after the test fixture has been set up.</span>
<a name="l00271"></a>00271   <span class="comment">//</span>
<a name="l00272"></a>00272   <span class="comment">// A sub-class must implement this to define the test logic.</span>
<a name="l00273"></a>00273   <span class="comment">//</span>
<a name="l00274"></a>00274   <span class="comment">// DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.</span>
<a name="l00275"></a>00275   <span class="comment">// Instead, use the TEST or TEST_F macro.</span>
<a name="l00276"></a>00276   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#7c987a80f78dec5eba1aee0b9bb726a8">TestBody</a>() = 0;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278   <span class="comment">// Sets up, executes, and tears down the test.</span>
<a name="l00279"></a>00279   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#9cc0df5ee0753f4578f12e0e72c1aa85">Run</a>();
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="comment">// Uses a GTestFlagSaver to save and restore all Google Test flags.</span>
<a name="l00282"></a><a class="code" href="classtesting_1_1Test.html#11223d23ca155b8a85bf63b8f1b0074c">00282</a>   <span class="keyword">const</span> internal::GTestFlagSaver* <span class="keyword">const</span> gtest_flag_saver_;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="comment">// Often a user mis-spells SetUp() as Setup() and spends a long time</span>
<a name="l00285"></a>00285   <span class="comment">// wondering why it is never called by Google Test.  The declaration of</span>
<a name="l00286"></a>00286   <span class="comment">// the following method is solely for catching such an error at</span>
<a name="l00287"></a>00287   <span class="comment">// compile time:</span>
<a name="l00288"></a>00288   <span class="comment">//</span>
<a name="l00289"></a>00289   <span class="comment">//   - The return type is deliberately chosen to be not void, so it</span>
<a name="l00290"></a>00290   <span class="comment">//   will be a conflict if a user declares void Setup() in his test</span>
<a name="l00291"></a>00291   <span class="comment">//   fixture.</span>
<a name="l00292"></a>00292   <span class="comment">//</span>
<a name="l00293"></a>00293   <span class="comment">//   - This method is private, so it will be another compiler error</span>
<a name="l00294"></a>00294   <span class="comment">//   if a user calls it from his test fixture.</span>
<a name="l00295"></a>00295   <span class="comment">//</span>
<a name="l00296"></a>00296   <span class="comment">// DO NOT OVERRIDE THIS FUNCTION.</span>
<a name="l00297"></a>00297   <span class="comment">//</span>
<a name="l00298"></a>00298   <span class="comment">// If you see an error about overriding the following function or</span>
<a name="l00299"></a>00299   <span class="comment">// about it being private, you have mis-spelled SetUp() as Setup().</span>
<a name="l00300"></a><a class="code" href="structtesting_1_1Test_1_1Setup__should__be__spelled__SetUp.html">00300</a>   <span class="keyword">struct </span><a class="code" href="structtesting_1_1Test_1_1Setup__should__be__spelled__SetUp.html">Setup_should_be_spelled_SetUp</a> {};
<a name="l00301"></a><a class="code" href="classtesting_1_1Test.html#9d4162224b354f9d29e0816d89dde567">00301</a>   <span class="keyword">virtual</span> <a class="code" href="structtesting_1_1Test_1_1Setup__should__be__spelled__SetUp.html">Setup_should_be_spelled_SetUp</a>* <a class="code" href="classtesting_1_1Test.html#9d4162224b354f9d29e0816d89dde567">Setup</a>() { <span class="keywordflow">return</span> NULL; }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   <span class="comment">// We disallow copying Tests.</span>
<a name="l00304"></a>00304   <a class="code" href="classtesting_1_1Test.html#29540d1bf03baf570118c6e56e4ae901">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1Test.html">Test</a>);
<a name="l00305"></a>00305 };
<a name="l00306"></a>00306 
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="comment">// A TestInfo object stores the following information about a test:</span>
<a name="l00309"></a>00309 <span class="comment">//</span>
<a name="l00310"></a>00310 <span class="comment">//   Test case name</span>
<a name="l00311"></a>00311 <span class="comment">//   Test name</span>
<a name="l00312"></a>00312 <span class="comment">//   Whether the test should be run</span>
<a name="l00313"></a>00313 <span class="comment">//   A function pointer that creates the test object when invoked</span>
<a name="l00314"></a>00314 <span class="comment">//   Test result</span>
<a name="l00315"></a>00315 <span class="comment">//</span>
<a name="l00316"></a>00316 <span class="comment">// The constructor of TestInfo registers itself with the UnitTest</span>
<a name="l00317"></a>00317 <span class="comment">// singleton such that the RUN_ALL_TESTS() macro knows which tests to</span>
<a name="l00318"></a>00318 <span class="comment">// run.</span>
<a name="l00319"></a><a class="code" href="classtesting_1_1TestInfo.html">00319</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a> {
<a name="l00320"></a>00320  <span class="keyword">public</span>:
<a name="l00321"></a>00321   <span class="comment">// Destructs a TestInfo object.  This function is not virtual, so</span>
<a name="l00322"></a>00322   <span class="comment">// don't inherit from TestInfo.</span>
<a name="l00323"></a>00323   <a class="code" href="classtesting_1_1TestInfo.html#5a6046a6bc1990cd3d34b777d1ea2efb">~TestInfo</a>();
<a name="l00324"></a>00324 
<a name="l00325"></a>00325   <span class="comment">// Returns the test case name.</span>
<a name="l00326"></a>00326   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#ce66c230c07aadcacb59fe050b10048c">test_case_name</a>() <span class="keyword">const</span>;
<a name="l00327"></a>00327 
<a name="l00328"></a>00328   <span class="comment">// Returns the test name.</span>
<a name="l00329"></a>00329   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#98187c43314e8e23cc6ccdccb5465d50">name</a>() <span class="keyword">const</span>;
<a name="l00330"></a>00330 
<a name="l00331"></a>00331   <span class="comment">// Returns the test case comment.</span>
<a name="l00332"></a>00332   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#000a4260add151f8f8fdb5f94b0d4f74">test_case_comment</a>() <span class="keyword">const</span>;
<a name="l00333"></a>00333 
<a name="l00334"></a>00334   <span class="comment">// Returns the test comment.</span>
<a name="l00335"></a>00335   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#f2dd6a2ad5fccba8f0bbcc52d5664bca">comment</a>() <span class="keyword">const</span>;
<a name="l00336"></a>00336 
<a name="l00337"></a>00337   <span class="comment">// Returns true if this test should run.</span>
<a name="l00338"></a>00338   <span class="comment">//</span>
<a name="l00339"></a>00339   <span class="comment">// Google Test allows the user to filter the tests by their full names.</span>
<a name="l00340"></a>00340   <span class="comment">// The full name of a test Bar in test case Foo is defined as</span>
<a name="l00341"></a>00341   <span class="comment">// "Foo.Bar".  Only the tests that match the filter will run.</span>
<a name="l00342"></a>00342   <span class="comment">//</span>
<a name="l00343"></a>00343   <span class="comment">// A filter is a colon-separated list of glob (not regex) patterns,</span>
<a name="l00344"></a>00344   <span class="comment">// optionally followed by a '-' and a colon-separated list of</span>
<a name="l00345"></a>00345   <span class="comment">// negative patterns (tests to exclude).  A test is run if it</span>
<a name="l00346"></a>00346   <span class="comment">// matches one of the positive patterns and does not match any of</span>
<a name="l00347"></a>00347   <span class="comment">// the negative patterns.</span>
<a name="l00348"></a>00348   <span class="comment">//</span>
<a name="l00349"></a>00349   <span class="comment">// For example, *A*:Foo.* is a filter that matches any string that</span>
<a name="l00350"></a>00350   <span class="comment">// contains the character 'A' or starts with "Foo.".</span>
<a name="l00351"></a>00351   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestInfo.html#27e8a3d5b459a30df5e9981645c190b0">should_run</a>() <span class="keyword">const</span>;
<a name="l00352"></a>00352 
<a name="l00353"></a>00353   <span class="comment">// Returns the result of the test.</span>
<a name="l00354"></a><a class="code" href="classtesting_1_1TestInfo.html#8351d36043af6c595e9662daea88bea3">00354</a>   <span class="keyword">const</span> internal::TestResult* result() <span class="keyword">const</span>;
<a name="l00355"></a>00355  <span class="keyword">private</span>:
<a name="l00356"></a>00356 <span class="preprocessor">#ifdef GTEST_HAS_DEATH_TEST</span>
<a name="l00357"></a>00357 <span class="preprocessor"></span>  <span class="keyword">friend</span> <span class="keyword">class </span>internal::DefaultDeathTestFactory;
<a name="l00358"></a>00358 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST</span>
<a name="l00359"></a><a class="code" href="classtesting_1_1TestInfo.html#5aa7b30faff2d57475f7e9eea1bc8eaa">00359</a> <span class="preprocessor"></span>  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html#5aa7b30faff2d57475f7e9eea1bc8eaa">internal::TestInfoImpl</a>;
<a name="l00360"></a><a class="code" href="classtesting_1_1TestInfo.html#417e83bada4513ea82ec1daf57acefe0">00360</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html#417e83bada4513ea82ec1daf57acefe0">internal::UnitTestImpl</a>;
<a name="l00361"></a><a class="code" href="classtesting_1_1TestInfo.html#e7f33bcfe8b908f68c5bd4dfc6012078">00361</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1Test.html">Test</a>;
<a name="l00362"></a><a class="code" href="classtesting_1_1TestInfo.html#2831345fc3341f246c8c26ed33205687">00362</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html#2831345fc3341f246c8c26ed33205687">TestCase</a>;
<a name="l00363"></a>00363   <span class="keyword">friend</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>* <a class="code" href="namespacetesting_1_1internal.html#c8a4baccf925ac1c597b5bf7956d680e">internal::MakeAndRegisterTestInfo</a>(
<a name="l00364"></a><a class="code" href="classtesting_1_1TestInfo.html#f52d0a54d1988531c00a50ce9ca64e59">00364</a>       <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name, <span class="keyword">const</span> <span class="keywordtype">char</span>* name,
<a name="l00365"></a>00365       <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_comment, <span class="keyword">const</span> <span class="keywordtype">char</span>* comment,
<a name="l00366"></a>00366       <a class="code" href="namespacetesting_1_1internal.html#34ce8e1aa9380799f8456ee3a81ceb82">internal::TypeId</a> <a class="code" href="classtesting_1_1TestInfo.html#a50374588be33bcee7b1b28c4a0d89fb">fixture_class_id</a>,
<a name="l00367"></a>00367       <a class="code" href="namespacetesting_1_1internal.html#1b8518e7b2cdc051b4379b923be61d5d">Test::SetUpTestCaseFunc</a> <a class="code" href="classtesting_1_1TestInfo.html#8191266a160e91d889bbea316a7883ef">set_up_tc</a>,
<a name="l00368"></a>00368       <a class="code" href="namespacetesting_1_1internal.html#b87631eabafc70771cf3fb20be8b3adc">Test::TearDownTestCaseFunc</a> <a class="code" href="classtesting_1_1TestInfo.html#beba20073b35ead7e153d76034918252">tear_down_tc</a>,
<a name="l00369"></a>00369       <a class="code" href="classtesting_1_1internal_1_1TestFactoryBase.html">internal::TestFactoryBase</a>* <a class="code" href="classtesting_1_1TestInfo.html#b02555c7691ca9d0fb0bcca5ca328d2d">factory</a>);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="comment">// Increments the number of death tests encountered in this test so</span>
<a name="l00372"></a>00372   <span class="comment">// far.</span>
<a name="l00373"></a>00373   <span class="keywordtype">int</span> <a class="code" href="classtesting_1_1TestInfo.html#4e9380275eed7e67174b07336ebcb58f">increment_death_test_count</a>();
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">// Accessors for the implementation object.</span>
<a name="l00376"></a><a class="code" href="classtesting_1_1TestInfo.html#a1283eab082d57978d8c5b88ae552320">00376</a>   <a class="code" href="classtesting_1_1TestInfo.html#5aa7b30faff2d57475f7e9eea1bc8eaa">internal::TestInfoImpl</a>* <a class="code" href="classtesting_1_1TestInfo.html#a1283eab082d57978d8c5b88ae552320">impl</a>() { <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1TestInfo.html#a7cba6a8092514424ef3929120ba4e11">impl_</a>; }
<a name="l00377"></a><a class="code" href="classtesting_1_1TestInfo.html#786579989a4ac4253f63c41f71690098">00377</a>   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html#5aa7b30faff2d57475f7e9eea1bc8eaa">internal::TestInfoImpl</a>* <a class="code" href="classtesting_1_1TestInfo.html#a1283eab082d57978d8c5b88ae552320">impl</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1TestInfo.html#a7cba6a8092514424ef3929120ba4e11">impl_</a>; }
<a name="l00378"></a>00378 
<a name="l00379"></a>00379   <span class="comment">// Constructs a TestInfo object. The newly constructed instance assumes</span>
<a name="l00380"></a>00380   <span class="comment">// ownership of the factory object.</span>
<a name="l00381"></a>00381   <a class="code" href="classtesting_1_1TestInfo.html#0c48a55b93a44fbdc86311e095d03443">TestInfo</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name, <span class="keyword">const</span> <span class="keywordtype">char</span>* name,
<a name="l00382"></a>00382            <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_comment, <span class="keyword">const</span> <span class="keywordtype">char</span>* comment,
<a name="l00383"></a>00383            <a class="code" href="namespacetesting_1_1internal.html#34ce8e1aa9380799f8456ee3a81ceb82">internal::TypeId</a> <a class="code" href="classtesting_1_1TestInfo.html#a50374588be33bcee7b1b28c4a0d89fb">fixture_class_id</a>,
<a name="l00384"></a>00384            <a class="code" href="classtesting_1_1internal_1_1TestFactoryBase.html">internal::TestFactoryBase</a>* <a class="code" href="classtesting_1_1TestInfo.html#b02555c7691ca9d0fb0bcca5ca328d2d">factory</a>);
<a name="l00385"></a>00385 
<a name="l00386"></a>00386   <span class="comment">// An opaque implementation object.</span>
<a name="l00387"></a><a class="code" href="classtesting_1_1TestInfo.html#a7cba6a8092514424ef3929120ba4e11">00387</a>   <a class="code" href="classtesting_1_1TestInfo.html#5aa7b30faff2d57475f7e9eea1bc8eaa">internal::TestInfoImpl</a>* <a class="code" href="classtesting_1_1TestInfo.html#a7cba6a8092514424ef3929120ba4e11">impl_</a>;
<a name="l00388"></a>00388 
<a name="l00389"></a>00389   <a class="code" href="classtesting_1_1TestInfo.html#3f510e71137f11b5a90ecf843a171b0f">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>);
<a name="l00390"></a>00390 };
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 <span class="comment">// An Environment object is capable of setting up and tearing down an</span>
<a name="l00393"></a>00393 <span class="comment">// environment.  The user should subclass this to define his own</span>
<a name="l00394"></a>00394 <span class="comment">// environment(s).</span>
<a name="l00395"></a>00395 <span class="comment">//</span>
<a name="l00396"></a>00396 <span class="comment">// An Environment object does the set-up and tear-down in virtual</span>
<a name="l00397"></a>00397 <span class="comment">// methods SetUp() and TearDown() instead of the constructor and the</span>
<a name="l00398"></a>00398 <span class="comment">// destructor, as:</span>
<a name="l00399"></a>00399 <span class="comment">//</span>
<a name="l00400"></a>00400 <span class="comment">//   1. You cannot safely throw from a destructor.  This is a problem</span>
<a name="l00401"></a>00401 <span class="comment">//      as in some cases Google Test is used where exceptions are enabled, and</span>
<a name="l00402"></a>00402 <span class="comment">//      we may want to implement ASSERT_* using exceptions where they are</span>
<a name="l00403"></a>00403 <span class="comment">//      available.</span>
<a name="l00404"></a>00404 <span class="comment">//   2. You cannot use ASSERT_* directly in a constructor or</span>
<a name="l00405"></a>00405 <span class="comment">//      destructor.</span>
<a name="l00406"></a><a class="code" href="classtesting_1_1Environment.html">00406</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1Environment.html">Environment</a> {
<a name="l00407"></a>00407  <span class="keyword">public</span>:
<a name="l00408"></a>00408   <span class="comment">// The d'tor is virtual as we need to subclass Environment.</span>
<a name="l00409"></a><a class="code" href="classtesting_1_1Environment.html#1febe35c894ab431777a8ef7079f86c3">00409</a>   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1Environment.html#1febe35c894ab431777a8ef7079f86c3">~Environment</a>() {}
<a name="l00410"></a>00410 
<a name="l00411"></a>00411   <span class="comment">// Override this to define how to set up the environment.</span>
<a name="l00412"></a><a class="code" href="classtesting_1_1Environment.html#562c61c7087bc48651cfc1557af349ef">00412</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Environment.html#562c61c7087bc48651cfc1557af349ef">SetUp</a>() {}
<a name="l00413"></a>00413 
<a name="l00414"></a>00414   <span class="comment">// Override this to define how to tear down the environment.</span>
<a name="l00415"></a><a class="code" href="classtesting_1_1Environment.html#84a68fe128e6d09494c01c6031c0d8f7">00415</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Environment.html#84a68fe128e6d09494c01c6031c0d8f7">TearDown</a>() {}
<a name="l00416"></a>00416  <span class="keyword">private</span>:
<a name="l00417"></a>00417   <span class="comment">// If you see an error about overriding the following function or</span>
<a name="l00418"></a>00418   <span class="comment">// about it being private, you have mis-spelled SetUp() as Setup().</span>
<a name="l00419"></a><a class="code" href="structtesting_1_1Environment_1_1Setup__should__be__spelled__SetUp.html">00419</a>   <span class="keyword">struct </span><a class="code" href="structtesting_1_1Environment_1_1Setup__should__be__spelled__SetUp.html">Setup_should_be_spelled_SetUp</a> {};
<a name="l00420"></a><a class="code" href="classtesting_1_1Environment.html#4c1b9884d3ce6eb9a9866ea3b328c0c1">00420</a>   <span class="keyword">virtual</span> <a class="code" href="structtesting_1_1Environment_1_1Setup__should__be__spelled__SetUp.html">Setup_should_be_spelled_SetUp</a>* <a class="code" href="classtesting_1_1Environment.html#4c1b9884d3ce6eb9a9866ea3b328c0c1">Setup</a>() { <span class="keywordflow">return</span> NULL; }
<a name="l00421"></a>00421 };
<a name="l00422"></a>00422 
<a name="l00423"></a>00423 <span class="comment">// A UnitTest consists of a list of TestCases.</span>
<a name="l00424"></a>00424 <span class="comment">//</span>
<a name="l00425"></a>00425 <span class="comment">// This is a singleton class.  The only instance of UnitTest is</span>
<a name="l00426"></a>00426 <span class="comment">// created when UnitTest::GetInstance() is first called.  This</span>
<a name="l00427"></a>00427 <span class="comment">// instance is never deleted.</span>
<a name="l00428"></a>00428 <span class="comment">//</span>
<a name="l00429"></a>00429 <span class="comment">// UnitTest is not copyable.</span>
<a name="l00430"></a>00430 <span class="comment">//</span>
<a name="l00431"></a>00431 <span class="comment">// This class is thread-safe as long as the methods are called</span>
<a name="l00432"></a>00432 <span class="comment">// according to their specification.</span>
<a name="l00433"></a><a class="code" href="classtesting_1_1UnitTest.html">00433</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a> {
<a name="l00434"></a>00434  <span class="keyword">public</span>:
<a name="l00435"></a>00435   <span class="comment">// Gets the singleton UnitTest object.  The first time this method</span>
<a name="l00436"></a>00436   <span class="comment">// is called, a UnitTest object is constructed and returned.</span>
<a name="l00437"></a>00437   <span class="comment">// Consecutive calls will return the same object.</span>
<a name="l00438"></a>00438   <span class="keyword">static</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>* <a class="code" href="classtesting_1_1UnitTest.html#db04e1d682a2d7cfc3aa2c5afe3cac5f">GetInstance</a>();
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">// Registers and returns a global test environment.  When a test</span>
<a name="l00441"></a>00441   <span class="comment">// program is run, all global test environments will be set-up in</span>
<a name="l00442"></a>00442   <span class="comment">// the order they were registered.  After all tests in the program</span>
<a name="l00443"></a>00443   <span class="comment">// have finished, all global test environments will be torn-down in</span>
<a name="l00444"></a>00444   <span class="comment">// the *reverse* order they were registered.</span>
<a name="l00445"></a>00445   <span class="comment">//</span>
<a name="l00446"></a>00446   <span class="comment">// The UnitTest object takes ownership of the given environment.</span>
<a name="l00447"></a>00447   <span class="comment">//</span>
<a name="l00448"></a>00448   <span class="comment">// This method can only be called from the main thread.</span>
<a name="l00449"></a>00449   <a class="code" href="classtesting_1_1Environment.html">Environment</a>* <a class="code" href="classtesting_1_1UnitTest.html#b1427eccd1c7b3fd6a033e22d52cbdee">AddEnvironment</a>(<a class="code" href="classtesting_1_1Environment.html">Environment</a>* env);
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <span class="comment">// Adds a TestPartResult to the current TestResult object.  All</span>
<a name="l00452"></a>00452   <span class="comment">// Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)</span>
<a name="l00453"></a>00453   <span class="comment">// eventually call this to report their results.  The user code</span>
<a name="l00454"></a>00454   <span class="comment">// should use the assertion macros instead of calling this directly.</span>
<a name="l00455"></a>00455   <span class="comment">//</span>
<a name="l00456"></a>00456   <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00457"></a>00457   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1UnitTest.html#fad5417ce02bc444a32f6e1659729a80">AddTestPartResult</a>(<a class="code" href="namespacetesting.html#e87109d90628580ab2d751fcb36fc975">TestPartResultType</a> result_type,
<a name="l00458"></a>00458                          <span class="keyword">const</span> <span class="keywordtype">char</span>* file_name,
<a name="l00459"></a>00459                          <span class="keywordtype">int</span> line_number,
<a name="l00460"></a>00460                          <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1String.html">internal::String</a>&amp; message,
<a name="l00461"></a>00461                          <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1String.html">internal::String</a>&amp; os_stack_trace);
<a name="l00462"></a>00462 
<a name="l00463"></a>00463   <span class="comment">// Adds a TestProperty to the current TestResult object. If the result already</span>
<a name="l00464"></a>00464   <span class="comment">// contains a property with the same key, the value will be updated.</span>
<a name="l00465"></a>00465   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1UnitTest.html#aa1fa510a34fb035d88bc5e615fbbd1e">RecordPropertyForCurrentTest</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* key, <span class="keyword">const</span> <span class="keywordtype">char</span>* value);
<a name="l00466"></a>00466 
<a name="l00467"></a>00467   <span class="comment">// Runs all tests in this UnitTest object and prints the result.</span>
<a name="l00468"></a>00468   <span class="comment">// Returns 0 if successful, or 1 otherwise.</span>
<a name="l00469"></a>00469   <span class="comment">//</span>
<a name="l00470"></a>00470   <span class="comment">// This method can only be called from the main thread.</span>
<a name="l00471"></a>00471   <span class="comment">//</span>
<a name="l00472"></a>00472   <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00473"></a>00473   <span class="keywordtype">int</span> <a class="code" href="classtesting_1_1UnitTest.html#5fd408b9dd00b8b3495ef66428fa6d1c">Run</a>() <a class="code" href="gtest-port_8h.html#278b3d9816b7f2389f2cf362e8ba6a3c">GTEST_MUST_USE_RESULT_</a>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475   <span class="comment">// Returns the working directory when the first TEST() or TEST_F()</span>
<a name="l00476"></a>00476   <span class="comment">// was executed.  The UnitTest object owns the string.</span>
<a name="l00477"></a>00477   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1UnitTest.html#8e3dd65ddd6627667a394e909c0687b4">original_working_dir</a>() <span class="keyword">const</span>;
<a name="l00478"></a>00478 
<a name="l00479"></a>00479   <span class="comment">// Returns the TestCase object for the test that's currently running,</span>
<a name="l00480"></a>00480   <span class="comment">// or NULL if no test is running.</span>
<a name="l00481"></a>00481   <span class="keyword">const</span> TestCase* <a class="code" href="classtesting_1_1UnitTest.html#d40c5de4a9dada54bbb7b9d4b5f28925">current_test_case</a>() <span class="keyword">const</span>;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483   <span class="comment">// Returns the TestInfo object for the test that's currently running,</span>
<a name="l00484"></a>00484   <span class="comment">// or NULL if no test is running.</span>
<a name="l00485"></a>00485   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>* <a class="code" href="classtesting_1_1UnitTest.html#5e8e59d2d42a24233183a0974d02dd40">current_test_info</a>() <span class="keyword">const</span>;
<a name="l00486"></a>00486 
<a name="l00487"></a>00487 <span class="preprocessor">#ifdef GTEST_HAS_PARAM_TEST</span>
<a name="l00488"></a>00488 <span class="preprocessor"></span>  <span class="comment">// Returns the ParameterizedTestCaseRegistry object used to keep track of</span>
<a name="l00489"></a>00489   <span class="comment">// value-parameterized tests and instantiate and register them.</span>
<a name="l00490"></a>00490   internal::ParameterizedTestCaseRegistry&amp; parameterized_test_registry();
<a name="l00491"></a>00491 <span class="preprocessor">#endif  // GTEST_HAS_PARAM_TEST</span>
<a name="l00492"></a>00492 <span class="preprocessor"></span>
<a name="l00493"></a>00493   <span class="comment">// Accessors for the implementation object.</span>
<a name="l00494"></a><a class="code" href="classtesting_1_1UnitTest.html#c6c28ca92bf6f5341970f01987f16711">00494</a>   internal::UnitTestImpl* <a class="code" href="classtesting_1_1UnitTest.html#c6c28ca92bf6f5341970f01987f16711">impl</a>() { <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1UnitTest.html#bdbc21d9a1264600a85748daef2a0c5a">impl_</a>; }
<a name="l00495"></a><a class="code" href="classtesting_1_1UnitTest.html#03aec0a97ab57c012431c86abdf69942">00495</a>   <span class="keyword">const</span> internal::UnitTestImpl* <a class="code" href="classtesting_1_1UnitTest.html#c6c28ca92bf6f5341970f01987f16711">impl</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1UnitTest.html#bdbc21d9a1264600a85748daef2a0c5a">impl_</a>; }
<a name="l00496"></a>00496  <span class="keyword">private</span>:
<a name="l00497"></a>00497   <span class="comment">// ScopedTrace is a friend as it needs to modify the per-thread</span>
<a name="l00498"></a>00498   <span class="comment">// trace stack, which is a private member of UnitTest.</span>
<a name="l00499"></a><a class="code" href="classtesting_1_1UnitTest.html#d38a4df6f8f4b5b203b71edc50a4b815">00499</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ScopedTrace.html">internal::ScopedTrace</a>;
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="comment">// Creates an empty UnitTest.</span>
<a name="l00502"></a>00502   <a class="code" href="classtesting_1_1UnitTest.html#ad2f55aa951b8975930d7f4022feff08">UnitTest</a>();
<a name="l00503"></a>00503 
<a name="l00504"></a>00504   <span class="comment">// D'tor</span>
<a name="l00505"></a>00505   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1UnitTest.html#c320ce8c6d7eb6d02240c181ef30bb07">~UnitTest</a>();
<a name="l00506"></a>00506 
<a name="l00507"></a>00507   <span class="comment">// Pushes a trace defined by SCOPED_TRACE() on to the per-thread</span>
<a name="l00508"></a>00508   <span class="comment">// Google Test trace stack.</span>
<a name="l00509"></a>00509   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1UnitTest.html#8b32d06aa2322afcef8496aede274d70">PushGTestTrace</a>(<span class="keyword">const</span> internal::TraceInfo&amp; trace);
<a name="l00510"></a>00510 
<a name="l00511"></a>00511   <span class="comment">// Pops a trace from the per-thread Google Test trace stack.</span>
<a name="l00512"></a>00512   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1UnitTest.html#59b3b5d0b33814363fd9d4ff37c251f9">PopGTestTrace</a>();
<a name="l00513"></a>00513 
<a name="l00514"></a>00514   <span class="comment">// Protects mutable state in *impl_.  This is mutable as some const</span>
<a name="l00515"></a>00515   <span class="comment">// methods need to lock it too.</span>
<a name="l00516"></a><a class="code" href="classtesting_1_1UnitTest.html#700e6b4b815535175165bfca2f3a57b4">00516</a>   <span class="keyword">mutable</span> <a class="code" href="classtesting_1_1internal_1_1Mutex.html">internal::Mutex</a> <a class="code" href="classtesting_1_1UnitTest.html#700e6b4b815535175165bfca2f3a57b4">mutex_</a>;
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="comment">// Opaque implementation object.  This field is never changed once</span>
<a name="l00519"></a>00519   <span class="comment">// the object is constructed.  We don't mark it as const here, as</span>
<a name="l00520"></a>00520   <span class="comment">// doing so will cause a warning in the constructor of UnitTest.</span>
<a name="l00521"></a>00521   <span class="comment">// Mutable state in *impl_ is protected by mutex_.</span>
<a name="l00522"></a><a class="code" href="classtesting_1_1UnitTest.html#bdbc21d9a1264600a85748daef2a0c5a">00522</a>   internal::UnitTestImpl* <a class="code" href="classtesting_1_1UnitTest.html#bdbc21d9a1264600a85748daef2a0c5a">impl_</a>;
<a name="l00523"></a>00523 
<a name="l00524"></a>00524   <span class="comment">// We disallow copying UnitTest.</span>
<a name="l00525"></a>00525   <a class="code" href="classtesting_1_1UnitTest.html#599d5ac196b5b3408db7c44e3abc4e11">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>);
<a name="l00526"></a>00526 };
<a name="l00527"></a>00527 
<a name="l00528"></a>00528 <span class="comment">// A convenient wrapper for adding an environment for the test</span>
<a name="l00529"></a>00529 <span class="comment">// program.</span>
<a name="l00530"></a>00530 <span class="comment">//</span>
<a name="l00531"></a>00531 <span class="comment">// You should call this before RUN_ALL_TESTS() is called, probably in</span>
<a name="l00532"></a>00532 <span class="comment">// main().  If you use gtest_main, you need to call this before main()</span>
<a name="l00533"></a>00533 <span class="comment">// starts for it to take effect.  For example, you can define a global</span>
<a name="l00534"></a>00534 <span class="comment">// variable like this:</span>
<a name="l00535"></a>00535 <span class="comment">//</span>
<a name="l00536"></a>00536 <span class="comment">//   testing::Environment* const foo_env =</span>
<a name="l00537"></a>00537 <span class="comment">//       testing::AddGlobalTestEnvironment(new FooEnvironment);</span>
<a name="l00538"></a>00538 <span class="comment">//</span>
<a name="l00539"></a>00539 <span class="comment">// However, we strongly recommend you to write your own main() and</span>
<a name="l00540"></a>00540 <span class="comment">// call AddGlobalTestEnvironment() there, as relying on initialization</span>
<a name="l00541"></a>00541 <span class="comment">// of global variables makes the code harder to read and may cause</span>
<a name="l00542"></a>00542 <span class="comment">// problems when you register multiple environments from different</span>
<a name="l00543"></a>00543 <span class="comment">// translation units and the environments have dependencies among them</span>
<a name="l00544"></a>00544 <span class="comment">// (remember that the compiler doesn't guarantee the order in which</span>
<a name="l00545"></a>00545 <span class="comment">// global variables from different translation units are initialized).</span>
<a name="l00546"></a><a class="code" href="namespacetesting.html#14f739e29da2c05e23eb563597f31b22">00546</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1Environment.html">Environment</a>* <a class="code" href="namespacetesting.html#14f739e29da2c05e23eb563597f31b22">AddGlobalTestEnvironment</a>(<a class="code" href="classtesting_1_1Environment.html">Environment</a>* env) {
<a name="l00547"></a>00547   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1UnitTest.html#db04e1d682a2d7cfc3aa2c5afe3cac5f">UnitTest::GetInstance</a>()-&gt;<a class="code" href="classtesting_1_1UnitTest.html#b1427eccd1c7b3fd6a033e22d52cbdee">AddEnvironment</a>(env);
<a name="l00548"></a>00548 }
<a name="l00549"></a>00549 
<a name="l00550"></a>00550 <span class="comment">// Initializes Google Test.  This must be called before calling</span>
<a name="l00551"></a>00551 <span class="comment">// RUN_ALL_TESTS().  In particular, it parses a command line for the</span>
<a name="l00552"></a>00552 <span class="comment">// flags that Google Test recognizes.  Whenever a Google Test flag is</span>
<a name="l00553"></a>00553 <span class="comment">// seen, it is removed from argv, and *argc is decremented.</span>
<a name="l00554"></a>00554 <span class="comment">//</span>
<a name="l00555"></a>00555 <span class="comment">// No value is returned.  Instead, the Google Test flag variables are</span>
<a name="l00556"></a>00556 <span class="comment">// updated.</span>
<a name="l00557"></a>00557 <span class="comment">//</span>
<a name="l00558"></a>00558 <span class="comment">// Calling the function for the second time has no user-visible effect.</span>
<a name="l00559"></a>00559 <span class="keywordtype">void</span> <a class="code" href="namespacetesting.html#1995fbe86612c912ccc86d18f7e9ef6a">InitGoogleTest</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">char</span>** argv);
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="comment">// This overloaded version can be used in Windows programs compiled in</span>
<a name="l00562"></a>00562 <span class="comment">// UNICODE mode.</span>
<a name="l00563"></a>00563 <span class="keywordtype">void</span> <a class="code" href="namespacetesting.html#1995fbe86612c912ccc86d18f7e9ef6a">InitGoogleTest</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">wchar_t</span>** argv);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="keyword">namespace </span>internal {
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="comment">// These overloaded versions handle ::std::string and ::std::wstring.</span>
<a name="l00568"></a>00568 <span class="preprocessor">#if GTEST_HAS_STD_STRING</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span><span class="keyword">inline</span> String <a class="code" href="namespacetesting_1_1internal.html#53f1b197f129e00eb934a988dd5133c0">FormatForFailureMessage</a>(const ::std::string&amp; str) {
<a name="l00570"></a>00570   <span class="keywordflow">return</span> (Message() &lt;&lt; <span class="charliteral">'"'</span> &lt;&lt; str &lt;&lt; <span class="charliteral">'"'</span>).GetString();
<a name="l00571"></a>00571 }
<a name="l00572"></a>00572 <span class="preprocessor">#endif  // GTEST_HAS_STD_STRING</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>
<a name="l00574"></a>00574 <span class="preprocessor">#if GTEST_HAS_STD_WSTRING</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span><span class="keyword">inline</span> String <a class="code" href="namespacetesting_1_1internal.html#53f1b197f129e00eb934a988dd5133c0">FormatForFailureMessage</a>(const ::std::wstring&amp; wstr) {
<a name="l00576"></a>00576   <span class="keywordflow">return</span> (Message() &lt;&lt; <span class="stringliteral">"L\""</span> &lt;&lt; wstr &lt;&lt; <span class="charliteral">'"'</span>).GetString();
<a name="l00577"></a>00577 }
<a name="l00578"></a>00578 <span class="preprocessor">#endif  // GTEST_HAS_STD_WSTRING</span>
<a name="l00579"></a>00579 <span class="preprocessor"></span>
<a name="l00580"></a>00580 <span class="comment">// These overloaded versions handle ::string and ::wstring.</span>
<a name="l00581"></a>00581 <span class="preprocessor">#if GTEST_HAS_GLOBAL_STRING</span>
<a name="l00582"></a>00582 <span class="preprocessor"></span><span class="keyword">inline</span> String <a class="code" href="namespacetesting_1_1internal.html#53f1b197f129e00eb934a988dd5133c0">FormatForFailureMessage</a>(const ::string&amp; str) {
<a name="l00583"></a>00583   <span class="keywordflow">return</span> (Message() &lt;&lt; <span class="charliteral">'"'</span> &lt;&lt; str &lt;&lt; <span class="charliteral">'"'</span>).GetString();
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 <span class="preprocessor">#endif  // GTEST_HAS_GLOBAL_STRING</span>
<a name="l00586"></a>00586 <span class="preprocessor"></span>
<a name="l00587"></a>00587 <span class="preprocessor">#if GTEST_HAS_GLOBAL_WSTRING</span>
<a name="l00588"></a>00588 <span class="preprocessor"></span><span class="keyword">inline</span> String <a class="code" href="namespacetesting_1_1internal.html#53f1b197f129e00eb934a988dd5133c0">FormatForFailureMessage</a>(const ::wstring&amp; wstr) {
<a name="l00589"></a>00589   <span class="keywordflow">return</span> (Message() &lt;&lt; <span class="stringliteral">"L\""</span> &lt;&lt; wstr &lt;&lt; <span class="charliteral">'"'</span>).GetString();
<a name="l00590"></a>00590 }
<a name="l00591"></a>00591 <span class="preprocessor">#endif  // GTEST_HAS_GLOBAL_WSTRING</span>
<a name="l00592"></a>00592 <span class="preprocessor"></span>
<a name="l00593"></a>00593 <span class="comment">// Formats a comparison assertion (e.g. ASSERT_EQ, EXPECT_LT, and etc)</span>
<a name="l00594"></a>00594 <span class="comment">// operand to be used in a failure message.  The type (but not value)</span>
<a name="l00595"></a>00595 <span class="comment">// of the other operand may affect the format.  This allows us to</span>
<a name="l00596"></a>00596 <span class="comment">// print a char* as a raw pointer when it is compared against another</span>
<a name="l00597"></a>00597 <span class="comment">// char*, and print it as a C string when it is compared against an</span>
<a name="l00598"></a>00598 <span class="comment">// std::string object, for example.</span>
<a name="l00599"></a>00599 <span class="comment">//</span>
<a name="l00600"></a>00600 <span class="comment">// The default implementation ignores the type of the other operand.</span>
<a name="l00601"></a>00601 <span class="comment">// Some specialized versions are used to handle formatting wide or</span>
<a name="l00602"></a>00602 <span class="comment">// narrow C strings.</span>
<a name="l00603"></a>00603 <span class="comment">//</span>
<a name="l00604"></a>00604 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00605"></a>00605 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00606"></a><a class="code" href="namespacetesting_1_1internal.html#e47d3997f2f60c466b59eb389761ceed">00606</a> <a class="code" href="classtesting_1_1internal_1_1String.html">String</a> <a class="code" href="namespacetesting_1_1internal.html#e47d3997f2f60c466b59eb389761ceed">FormatForComparisonFailureMessage</a>(<span class="keyword">const</span> T1&amp; value,
<a name="l00607"></a>00607                                          <span class="keyword">const</span> T2&amp; <span class="comment">/* other_operand */</span>) {
<a name="l00608"></a>00608   <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#53f1b197f129e00eb934a988dd5133c0">FormatForFailureMessage</a>(value);
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="comment">// The helper function for {ASSERT|EXPECT}_EQ.</span>
<a name="l00612"></a>00612 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00613"></a><a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">00613</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">CmpHelperEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00614"></a>00614                             <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00615"></a>00615                             <span class="keyword">const</span> T1&amp; expected,
<a name="l00616"></a>00616                             <span class="keyword">const</span> T2&amp; actual) {
<a name="l00617"></a>00617   <span class="keywordflow">if</span> (expected == actual) {
<a name="l00618"></a>00618     <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#b729c66d933de254c89cddb7f3c71ec4">AssertionSuccess</a>();
<a name="l00619"></a>00619   }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621   <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#edef6e77f267b3a60fabda1428c6742c">EqFailure</a>(expected_expression,
<a name="l00622"></a>00622                    actual_expression,
<a name="l00623"></a>00623                    <a class="code" href="namespacetesting_1_1internal.html#e47d3997f2f60c466b59eb389761ceed">FormatForComparisonFailureMessage</a>(expected, actual),
<a name="l00624"></a>00624                    <a class="code" href="namespacetesting_1_1internal.html#e47d3997f2f60c466b59eb389761ceed">FormatForComparisonFailureMessage</a>(actual, expected),
<a name="l00625"></a>00625                    <span class="keyword">false</span>);
<a name="l00626"></a>00626 }
<a name="l00627"></a>00627 
<a name="l00628"></a>00628 <span class="comment">// With this overloaded version, we allow anonymous enums to be used</span>
<a name="l00629"></a>00629 <span class="comment">// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums</span>
<a name="l00630"></a>00630 <span class="comment">// can be implicitly cast to BiggestInt.</span>
<a name="l00631"></a>00631 <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">CmpHelperEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00632"></a>00632                             <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00633"></a>00633                             <a class="code" href="namespacetesting_1_1internal.html#9992177d67caf887d92231eb20bc23f7">BiggestInt</a> expected,
<a name="l00634"></a>00634                             <a class="code" href="namespacetesting_1_1internal.html#9992177d67caf887d92231eb20bc23f7">BiggestInt</a> actual);
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 <span class="comment">// The helper class for {ASSERT|EXPECT}_EQ.  The template argument</span>
<a name="l00637"></a>00637 <span class="comment">// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()</span>
<a name="l00638"></a>00638 <span class="comment">// is a null pointer literal.  The following default implementation is</span>
<a name="l00639"></a>00639 <span class="comment">// for lhs_is_null_literal being false.</span>
<a name="l00640"></a>00640 <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> lhs_is_null_literal&gt;
<a name="l00641"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper.html">00641</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1EqHelper.html">EqHelper</a> {
<a name="l00642"></a>00642  <span class="keyword">public</span>:
<a name="l00643"></a>00643   <span class="comment">// This templatized version is for the general case.</span>
<a name="l00644"></a>00644   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00645"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper.html#b60379c1c1456b9901ac99b9a9a3b0bf">00645</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="classtesting_1_1internal_1_1EqHelper.html#b60379c1c1456b9901ac99b9a9a3b0bf">Compare</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00646"></a>00646                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00647"></a>00647                                  <span class="keyword">const</span> T1&amp; expected,
<a name="l00648"></a>00648                                  <span class="keyword">const</span> T2&amp; actual) {
<a name="l00649"></a>00649     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">CmpHelperEQ</a>(expected_expression, actual_expression, expected,
<a name="l00650"></a>00650                        actual);
<a name="l00651"></a>00651   }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="comment">// With this overloaded version, we allow anonymous enums to be used</span>
<a name="l00654"></a>00654   <span class="comment">// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous</span>
<a name="l00655"></a>00655   <span class="comment">// enums can be implicitly cast to BiggestInt.</span>
<a name="l00656"></a>00656   <span class="comment">//</span>
<a name="l00657"></a>00657   <span class="comment">// Even though its body looks the same as the above version, we</span>
<a name="l00658"></a>00658   <span class="comment">// cannot merge the two, as it will make anonymous enums unhappy.</span>
<a name="l00659"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper.html#6e08bfbe40299a13f7ecfc1e83dffa47">00659</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="classtesting_1_1internal_1_1EqHelper.html#b60379c1c1456b9901ac99b9a9a3b0bf">Compare</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00660"></a>00660                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00661"></a>00661                                  <a class="code" href="namespacetesting_1_1internal.html#9992177d67caf887d92231eb20bc23f7">BiggestInt</a> expected,
<a name="l00662"></a>00662                                  <a class="code" href="namespacetesting_1_1internal.html#9992177d67caf887d92231eb20bc23f7">BiggestInt</a> actual) {
<a name="l00663"></a>00663     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">CmpHelperEQ</a>(expected_expression, actual_expression, expected,
<a name="l00664"></a>00664                        actual);
<a name="l00665"></a>00665   }
<a name="l00666"></a>00666 };
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 <span class="comment">// This specialization is used when the first argument to ASSERT_EQ()</span>
<a name="l00669"></a>00669 <span class="comment">// is a null pointer literal.</span>
<a name="l00670"></a>00670 <span class="keyword">template</span> &lt;&gt;
<a name="l00671"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper_3_01true_01_4.html">00671</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1EqHelper.html">EqHelper</a>&lt;true&gt; {
<a name="l00672"></a>00672  <span class="keyword">public</span>:
<a name="l00673"></a>00673   <span class="comment">// We define two overloaded versions of Compare().  The first</span>
<a name="l00674"></a>00674   <span class="comment">// version will be picked when the second argument to ASSERT_EQ() is</span>
<a name="l00675"></a>00675   <span class="comment">// NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or</span>
<a name="l00676"></a>00676   <span class="comment">// EXPECT_EQ(false, a_bool).</span>
<a name="l00677"></a>00677   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00678"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper_3_01true_01_4.html#5282d5770e00c45f40ba4824425e230c">00678</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="classtesting_1_1internal_1_1EqHelper.html#b60379c1c1456b9901ac99b9a9a3b0bf">Compare</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00679"></a>00679                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00680"></a>00680                                  <span class="keyword">const</span> T1&amp; expected,
<a name="l00681"></a>00681                                  <span class="keyword">const</span> T2&amp; actual) {
<a name="l00682"></a>00682     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">CmpHelperEQ</a>(expected_expression, actual_expression, expected,
<a name="l00683"></a>00683                        actual);
<a name="l00684"></a>00684   }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   <span class="comment">// This version will be picked when the second argument to</span>
<a name="l00687"></a>00687   <span class="comment">// ASSERT_EQ() is a pointer, e.g. ASSERT_EQ(NULL, a_pointer).</span>
<a name="l00688"></a>00688   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00689"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper_3_01true_01_4.html#fca81649a11ff352e877756d6954b0be">00689</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="classtesting_1_1internal_1_1EqHelper.html#b60379c1c1456b9901ac99b9a9a3b0bf">Compare</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00690"></a>00690                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00691"></a>00691                                  <span class="keyword">const</span> T1&amp; expected,
<a name="l00692"></a>00692                                  T2* actual) {
<a name="l00693"></a>00693     <span class="comment">// We already know that 'expected' is a null pointer.</span>
<a name="l00694"></a>00694     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#45932ad30a954e99267502602cb8f7d4">CmpHelperEQ</a>(expected_expression, actual_expression,
<a name="l00695"></a>00695                        static_cast&lt;T2*&gt;(NULL), actual);
<a name="l00696"></a>00696   }
<a name="l00697"></a>00697 };
<a name="l00698"></a>00698 
<a name="l00699"></a>00699 <span class="comment">// A macro for implementing the helper functions needed to implement</span>
<a name="l00700"></a>00700 <span class="comment">// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste</span>
<a name="l00701"></a>00701 <span class="comment">// of similar code.</span>
<a name="l00702"></a>00702 <span class="comment">//</span>
<a name="l00703"></a>00703 <span class="comment">// For each templatized helper function, we also define an overloaded</span>
<a name="l00704"></a>00704 <span class="comment">// version for BiggestInt in order to reduce code bloat and allow</span>
<a name="l00705"></a>00705 <span class="comment">// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled</span>
<a name="l00706"></a>00706 <span class="comment">// with gcc 4.</span>
<a name="l00707"></a>00707 <span class="comment">//</span>
<a name="l00708"></a>00708 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00709"></a><a class="code" href="gtest_8h.html#59438692ad37b6d6ce9cc1930b906391">00709</a> <span class="preprocessor">#define GTEST_IMPL_CMP_HELPER_(op_name, op)\</span>
<a name="l00710"></a>00710 <span class="preprocessor">template &lt;typename T1, typename T2&gt;\</span>
<a name="l00711"></a>00711 <span class="preprocessor">AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \</span>
<a name="l00712"></a>00712 <span class="preprocessor">                                   const T1&amp; val1, const T2&amp; val2) {\</span>
<a name="l00713"></a>00713 <span class="preprocessor">  if (val1 op val2) {\</span>
<a name="l00714"></a>00714 <span class="preprocessor">    return AssertionSuccess();\</span>
<a name="l00715"></a>00715 <span class="preprocessor">  } else {\</span>
<a name="l00716"></a>00716 <span class="preprocessor">    Message msg;\</span>
<a name="l00717"></a>00717 <span class="preprocessor">    msg &lt;&lt; "Expected: (" &lt;&lt; expr1 &lt;&lt; ") " #op " (" &lt;&lt; expr2\</span>
<a name="l00718"></a>00718 <span class="preprocessor">        &lt;&lt; "), actual: " &lt;&lt; FormatForComparisonFailureMessage(val1, val2)\</span>
<a name="l00719"></a>00719 <span class="preprocessor">        &lt;&lt; " vs " &lt;&lt; FormatForComparisonFailureMessage(val2, val1);\</span>
<a name="l00720"></a>00720 <span class="preprocessor">    return AssertionFailure(msg);\</span>
<a name="l00721"></a>00721 <span class="preprocessor">  }\</span>
<a name="l00722"></a>00722 <span class="preprocessor">}\</span>
<a name="l00723"></a>00723 <span class="preprocessor">AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \</span>
<a name="l00724"></a>00724 <span class="preprocessor">                                   BiggestInt val1, BiggestInt val2);</span>
<a name="l00725"></a>00725 <span class="preprocessor"></span>
<a name="l00726"></a>00726 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_NE</span>
<a name="l00729"></a>00729 <a class="code" href="gtest_8h.html#59438692ad37b6d6ce9cc1930b906391">GTEST_IMPL_CMP_HELPER_</a>(NE, !=)
<a name="l00730"></a>00730 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_LE</span>
<a name="l00731"></a>00731 <a class="code" href="gtest_8h.html#59438692ad37b6d6ce9cc1930b906391">GTEST_IMPL_CMP_HELPER_</a>(LE, &lt;=)
<a name="l00732"></a>00732 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_LT</span>
<a name="l00733"></a>00733 <a class="code" href="gtest_8h.html#59438692ad37b6d6ce9cc1930b906391">GTEST_IMPL_CMP_HELPER_</a>(LT, &lt; )
<a name="l00734"></a>00734 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_GE</span>
<a name="l00735"></a>00735 <a class="code" href="gtest_8h.html#59438692ad37b6d6ce9cc1930b906391">GTEST_IMPL_CMP_HELPER_</a>(GE, &gt;=)
<a name="l00736"></a>00736 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_GT</span>
<a name="l00737"></a>00737 <a class="code" href="gtest_8h.html#59438692ad37b6d6ce9cc1930b906391">GTEST_IMPL_CMP_HELPER_</a>(GT, &gt; )
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 <span class="preprocessor">#undef GTEST_IMPL_CMP_HELPER_</span>
<a name="l00740"></a>00740 <span class="preprocessor"></span>
<a name="l00741"></a>00741 <span class="comment">// The helper function for {ASSERT|EXPECT}_STREQ.</span>
<a name="l00742"></a>00742 <span class="comment">//</span>
<a name="l00743"></a>00743 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00744"></a>00744 AssertionResult <a class="code" href="namespacetesting_1_1internal.html#0fa5116298109df6acd3d919223e14db">CmpHelperSTREQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00745"></a>00745                                <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00746"></a>00746                                <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l00747"></a>00747                                <span class="keyword">const</span> <span class="keywordtype">char</span>* actual);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRCASEEQ.</span>
<a name="l00750"></a>00750 <span class="comment">//</span>
<a name="l00751"></a>00751 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00752"></a>00752 AssertionResult <a class="code" href="namespacetesting_1_1internal.html#d8dddafb54dad2b1aba566a0d5dbbe5c">CmpHelperSTRCASEEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00753"></a>00753                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00754"></a>00754                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l00755"></a>00755                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* actual);
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRNE.</span>
<a name="l00758"></a>00758 <span class="comment">//</span>
<a name="l00759"></a>00759 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00760"></a>00760 AssertionResult <a class="code" href="namespacetesting_1_1internal.html#51488673d7489dbbabf399905632070c">CmpHelperSTRNE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l00761"></a>00761                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l00762"></a>00762                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s1,
<a name="l00763"></a>00763                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s2);
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRCASENE.</span>
<a name="l00766"></a>00766 <span class="comment">//</span>
<a name="l00767"></a>00767 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00768"></a>00768 AssertionResult <a class="code" href="namespacetesting_1_1internal.html#33d1ce02617d6effefd951178e5036a9">CmpHelperSTRCASENE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l00769"></a>00769                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l00770"></a>00770                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* s1,
<a name="l00771"></a>00771                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* s2);
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="comment">// Helper function for *_STREQ on wide strings.</span>
<a name="l00775"></a>00775 <span class="comment">//</span>
<a name="l00776"></a>00776 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00777"></a>00777 AssertionResult <a class="code" href="namespacetesting_1_1internal.html#0fa5116298109df6acd3d919223e14db">CmpHelperSTREQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00778"></a>00778                                <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00779"></a>00779                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* expected,
<a name="l00780"></a>00780                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* actual);
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="comment">// Helper function for *_STRNE on wide strings.</span>
<a name="l00783"></a>00783 <span class="comment">//</span>
<a name="l00784"></a>00784 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00785"></a>00785 AssertionResult <a class="code" href="namespacetesting_1_1internal.html#51488673d7489dbbabf399905632070c">CmpHelperSTRNE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l00786"></a>00786                                <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l00787"></a>00787                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* s1,
<a name="l00788"></a>00788                                <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* s2);
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 }  <span class="comment">// namespace internal</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 <span class="comment">// IsSubstring() and IsNotSubstring() are intended to be used as the</span>
<a name="l00793"></a>00793 <span class="comment">// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by</span>
<a name="l00794"></a>00794 <span class="comment">// themselves.  They check whether needle is a substring of haystack</span>
<a name="l00795"></a>00795 <span class="comment">// (NULL is considered a substring of itself only), and return an</span>
<a name="l00796"></a>00796 <span class="comment">// appropriate error message when they fail.</span>
<a name="l00797"></a>00797 <span class="comment">//</span>
<a name="l00798"></a>00798 <span class="comment">// The {needle,haystack}_expr arguments are the stringified</span>
<a name="l00799"></a>00799 <span class="comment">// expressions that generated the two real arguments.</span>
<a name="l00800"></a>00800 AssertionResult <a class="code" href="namespacetesting.html#009f08dca0562680a5704f6f88858ed3">IsSubstring</a>(
<a name="l00801"></a>00801     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00802"></a>00802     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack);
<a name="l00803"></a>00803 AssertionResult <a class="code" href="namespacetesting.html#009f08dca0562680a5704f6f88858ed3">IsSubstring</a>(
<a name="l00804"></a>00804     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00805"></a>00805     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack);
<a name="l00806"></a>00806 AssertionResult <a class="code" href="namespacetesting.html#1301ced25bb95bc43c5c9e9fd01d5270">IsNotSubstring</a>(
<a name="l00807"></a>00807     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00808"></a>00808     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack);
<a name="l00809"></a>00809 AssertionResult <a class="code" href="namespacetesting.html#1301ced25bb95bc43c5c9e9fd01d5270">IsNotSubstring</a>(
<a name="l00810"></a>00810     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00811"></a>00811     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack);
<a name="l00812"></a>00812 <span class="preprocessor">#if GTEST_HAS_STD_STRING</span>
<a name="l00813"></a>00813 <span class="preprocessor"></span>AssertionResult <a class="code" href="namespacetesting.html#009f08dca0562680a5704f6f88858ed3">IsSubstring</a>(
<a name="l00814"></a>00814     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00815"></a>00815     const ::std::string&amp; needle, const ::std::string&amp; haystack);
<a name="l00816"></a>00816 AssertionResult <a class="code" href="namespacetesting.html#1301ced25bb95bc43c5c9e9fd01d5270">IsNotSubstring</a>(
<a name="l00817"></a>00817     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00818"></a>00818     const ::std::string&amp; needle, const ::std::string&amp; haystack);
<a name="l00819"></a>00819 <span class="preprocessor">#endif  // GTEST_HAS_STD_STRING</span>
<a name="l00820"></a>00820 <span class="preprocessor"></span>
<a name="l00821"></a>00821 <span class="preprocessor">#if GTEST_HAS_STD_WSTRING</span>
<a name="l00822"></a>00822 <span class="preprocessor"></span>AssertionResult <a class="code" href="namespacetesting.html#009f08dca0562680a5704f6f88858ed3">IsSubstring</a>(
<a name="l00823"></a>00823     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00824"></a>00824     const ::std::wstring&amp; needle, const ::std::wstring&amp; haystack);
<a name="l00825"></a>00825 AssertionResult <a class="code" href="namespacetesting.html#1301ced25bb95bc43c5c9e9fd01d5270">IsNotSubstring</a>(
<a name="l00826"></a>00826     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l00827"></a>00827     const ::std::wstring&amp; needle, const ::std::wstring&amp; haystack);
<a name="l00828"></a>00828 <span class="preprocessor">#endif  // GTEST_HAS_STD_WSTRING</span>
<a name="l00829"></a>00829 <span class="preprocessor"></span>
<a name="l00830"></a>00830 <span class="keyword">namespace </span>internal {
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="comment">// Helper template function for comparing floating-points.</span>
<a name="l00833"></a>00833 <span class="comment">//</span>
<a name="l00834"></a>00834 <span class="comment">// Template parameter:</span>
<a name="l00835"></a>00835 <span class="comment">//</span>
<a name="l00836"></a>00836 <span class="comment">//   RawType: the raw floating-point type (either float or double)</span>
<a name="l00837"></a>00837 <span class="comment">//</span>
<a name="l00838"></a>00838 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00839"></a>00839 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> RawType&gt;
<a name="l00840"></a><a class="code" href="namespacetesting_1_1internal.html#0cbdac3d4f193f9e41b888a23967ce49">00840</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#0cbdac3d4f193f9e41b888a23967ce49">CmpHelperFloatingPointEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l00841"></a>00841                                          <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l00842"></a>00842                                          RawType expected,
<a name="l00843"></a>00843                                          RawType actual) {
<a name="l00844"></a>00844   <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1FloatingPoint.html">FloatingPoint&lt;RawType&gt;</a> lhs(expected), rhs(actual);
<a name="l00845"></a>00845 
<a name="l00846"></a>00846   <span class="keywordflow">if</span> (lhs.AlmostEquals(rhs)) {
<a name="l00847"></a>00847     <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#b729c66d933de254c89cddb7f3c71ec4">AssertionSuccess</a>();
<a name="l00848"></a>00848   }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850   <a class="code" href="namespacetesting_1_1internal.html#2f325a1ea8cfd7eab6843eb4592dde44">StrStream</a> expected_ss;
<a name="l00851"></a>00851   expected_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)
<a name="l00852"></a>00852               &lt;&lt; expected;
<a name="l00853"></a>00853 
<a name="l00854"></a>00854   <a class="code" href="namespacetesting_1_1internal.html#2f325a1ea8cfd7eab6843eb4592dde44">StrStream</a> actual_ss;
<a name="l00855"></a>00855   actual_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)
<a name="l00856"></a>00856             &lt;&lt; actual;
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#edef6e77f267b3a60fabda1428c6742c">EqFailure</a>(expected_expression,
<a name="l00859"></a>00859                    actual_expression,
<a name="l00860"></a>00860                    <a class="code" href="namespacetesting_1_1internal.html#5639f5bf1b9983c51ef166207d2c62b8">StrStreamToString</a>(&amp;expected_ss),
<a name="l00861"></a>00861                    <a class="code" href="namespacetesting_1_1internal.html#5639f5bf1b9983c51ef166207d2c62b8">StrStreamToString</a>(&amp;actual_ss),
<a name="l00862"></a>00862                    <span class="keyword">false</span>);
<a name="l00863"></a>00863 }
<a name="l00864"></a>00864 
<a name="l00865"></a>00865 <span class="comment">// Helper function for implementing ASSERT_NEAR.</span>
<a name="l00866"></a>00866 <span class="comment">//</span>
<a name="l00867"></a>00867 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00868"></a>00868 <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#2ffeb072172886ea1185c03dda4b0d76">DoubleNearPredFormat</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1,
<a name="l00869"></a>00869                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l00870"></a>00870                                      <span class="keyword">const</span> <span class="keywordtype">char</span>* abs_error_expr,
<a name="l00871"></a>00871                                      <span class="keywordtype">double</span> val1,
<a name="l00872"></a>00872                                      <span class="keywordtype">double</span> val2,
<a name="l00873"></a>00873                                      <span class="keywordtype">double</span> abs_error);
<a name="l00874"></a>00874 
<a name="l00875"></a>00875 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</span>
<a name="l00876"></a>00876 <span class="comment">// A class that enables one to stream messages to assertion macros</span>
<a name="l00877"></a><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">00877</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">AssertHelper</a> {
<a name="l00878"></a>00878  <span class="keyword">public</span>:
<a name="l00879"></a>00879   <span class="comment">// Constructor.</span>
<a name="l00880"></a>00880   <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#f28f11ad1b22a81480325011929068bb">AssertHelper</a>(<a class="code" href="namespacetesting.html#e87109d90628580ab2d751fcb36fc975">TestPartResultType</a> type, <span class="keyword">const</span> <span class="keywordtype">char</span>* file, <span class="keywordtype">int</span> line,
<a name="l00881"></a>00881                <span class="keyword">const</span> <span class="keywordtype">char</span>* message);
<a name="l00882"></a>00882   <span class="comment">// Message assignment is a semantic trick to enable assertion</span>
<a name="l00883"></a>00883   <span class="comment">// streaming; see the GTEST_MESSAGE_ macro below.</span>
<a name="l00884"></a>00884   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#f34713ddd123368c1453da566f54fe9c">operator=</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Message.html">Message</a>&amp; message) <span class="keyword">const</span>;
<a name="l00885"></a>00885  <span class="keyword">private</span>:
<a name="l00886"></a><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#8d7abde365f98254e2220f5affd41853">00886</a>   <a class="code" href="namespacetesting.html#e87109d90628580ab2d751fcb36fc975">TestPartResultType</a> <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#8d7abde365f98254e2220f5affd41853">type_</a>;
<a name="l00887"></a><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#2f390e195e3b1ea244c62d77c6d39051">00887</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>*        <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#2f390e195e3b1ea244c62d77c6d39051">file_</a>;
<a name="l00888"></a><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#7c7cef5c21780f81b597233bccaacbe3">00888</a>   <span class="keywordtype">int</span>                <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#7c7cef5c21780f81b597233bccaacbe3">line_</a>;
<a name="l00889"></a><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#fa76642e1a4a34a970bcd5a2360bafa7">00889</a>   <a class="code" href="classtesting_1_1internal_1_1String.html">String</a>             <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#fa76642e1a4a34a970bcd5a2360bafa7">message_</a>;
<a name="l00890"></a>00890 
<a name="l00891"></a>00891   <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html#3fa661b6161d44c4fd054f7d8d47cb46">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">AssertHelper</a>);
<a name="l00892"></a>00892 };
<a name="l00893"></a>00893 
<a name="l00894"></a>00894 }  <span class="comment">// namespace internal</span>
<a name="l00895"></a>00895 
<a name="l00896"></a>00896 <span class="preprocessor">#ifdef GTEST_HAS_PARAM_TEST</span>
<a name="l00897"></a>00897 <span class="preprocessor"></span><span class="comment">// The abstract base class that all value-parameterized tests inherit from.</span>
<a name="l00898"></a>00898 <span class="comment">//</span>
<a name="l00899"></a>00899 <span class="comment">// This class adds support for accessing the test parameter value via</span>
<a name="l00900"></a>00900 <span class="comment">// the GetParam() method.</span>
<a name="l00901"></a>00901 <span class="comment">//</span>
<a name="l00902"></a>00902 <span class="comment">// Use it with one of the parameter generator defining functions, like Range(),</span>
<a name="l00903"></a>00903 <span class="comment">// Values(), ValuesIn(), Bool(), and Combine().</span>
<a name="l00904"></a>00904 <span class="comment">//</span>
<a name="l00905"></a>00905 <span class="comment">// class FooTest : public ::testing::TestWithParam&lt;int&gt; {</span>
<a name="l00906"></a>00906 <span class="comment">//  protected:</span>
<a name="l00907"></a>00907 <span class="comment">//   FooTest() {</span>
<a name="l00908"></a>00908 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l00909"></a>00909 <span class="comment">//   }</span>
<a name="l00910"></a>00910 <span class="comment">//   virtual ~FooTest() {</span>
<a name="l00911"></a>00911 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l00912"></a>00912 <span class="comment">//   }</span>
<a name="l00913"></a>00913 <span class="comment">//   virtual void SetUp() {</span>
<a name="l00914"></a>00914 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l00915"></a>00915 <span class="comment">//   }</span>
<a name="l00916"></a>00916 <span class="comment">//   virtual void TearDown {</span>
<a name="l00917"></a>00917 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l00918"></a>00918 <span class="comment">//   }</span>
<a name="l00919"></a>00919 <span class="comment">// };</span>
<a name="l00920"></a>00920 <span class="comment">// TEST_P(FooTest, DoesBar) {</span>
<a name="l00921"></a>00921 <span class="comment">//   // Can use GetParam() method here.</span>
<a name="l00922"></a>00922 <span class="comment">//   Foo foo;</span>
<a name="l00923"></a>00923 <span class="comment">//   ASSERT_TRUE(foo.DoesBar(GetParam()));</span>
<a name="l00924"></a>00924 <span class="comment">// }</span>
<a name="l00925"></a>00925 <span class="comment">// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));</span>
<a name="l00926"></a>00926 
<a name="l00927"></a>00927 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00928"></a>00928 <span class="keyword">class </span>TestWithParam : <span class="keyword">public</span> <a class="code" href="classtesting_1_1Test.html">Test</a> {
<a name="l00929"></a>00929  <span class="keyword">public</span>:
<a name="l00930"></a>00930   <span class="keyword">typedef</span> T ParamType;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932   <span class="comment">// The current parameter value. Is also available in the test fixture's</span>
<a name="l00933"></a>00933   <span class="comment">// constructor.</span>
<a name="l00934"></a>00934   <span class="keyword">const</span> ParamType&amp; GetParam()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *parameter_; }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936  <span class="keyword">private</span>:
<a name="l00937"></a>00937   <span class="comment">// Sets parameter value. The caller is responsible for making sure the value</span>
<a name="l00938"></a>00938   <span class="comment">// remains alive and unchanged throughout the current test.</span>
<a name="l00939"></a>00939   <span class="keyword">static</span> <span class="keywordtype">void</span> SetParam(<span class="keyword">const</span> ParamType* parameter) {
<a name="l00940"></a>00940     parameter_ = parameter;
<a name="l00941"></a>00941   }
<a name="l00942"></a>00942 
<a name="l00943"></a>00943   <span class="comment">// Static value used for accessing parameter during a test lifetime.</span>
<a name="l00944"></a>00944   <span class="keyword">static</span> <span class="keyword">const</span> ParamType* parameter_;
<a name="l00945"></a>00945 
<a name="l00946"></a>00946   <span class="comment">// TestClass must be a subclass of TestWithParam&lt;T&gt;.</span>
<a name="l00947"></a>00947   <span class="keyword">template</span> &lt;<span class="keyword">class</span> TestClass&gt; <span class="keyword">friend</span> <span class="keyword">class </span>internal::ParameterizedTestFactory;
<a name="l00948"></a>00948 };
<a name="l00949"></a>00949 
<a name="l00950"></a>00950 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00951"></a>00951 <span class="keyword">const</span> T* TestWithParam&lt;T&gt;::parameter_ = NULL;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953 <span class="preprocessor">#endif  // GTEST_HAS_PARAM_TEST</span>
<a name="l00954"></a>00954 <span class="preprocessor"></span>
<a name="l00955"></a>00955 <span class="comment">// Macros for indicating success/failure in test code.</span>
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 <span class="comment">// ADD_FAILURE unconditionally adds a failure to the current test.</span>
<a name="l00958"></a>00958 <span class="comment">// SUCCEED generates a success - it doesn't automatically make the</span>
<a name="l00959"></a>00959 <span class="comment">// current test successful, as a test is only successful when it has</span>
<a name="l00960"></a>00960 <span class="comment">// no failure.</span>
<a name="l00961"></a>00961 <span class="comment">//</span>
<a name="l00962"></a>00962 <span class="comment">// EXPECT_* verifies that a certain condition is satisfied.  If not,</span>
<a name="l00963"></a>00963 <span class="comment">// it behaves like ADD_FAILURE.  In particular:</span>
<a name="l00964"></a>00964 <span class="comment">//</span>
<a name="l00965"></a>00965 <span class="comment">//   EXPECT_TRUE  verifies that a Boolean condition is true.</span>
<a name="l00966"></a>00966 <span class="comment">//   EXPECT_FALSE verifies that a Boolean condition is false.</span>
<a name="l00967"></a>00967 <span class="comment">//</span>
<a name="l00968"></a>00968 <span class="comment">// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except</span>
<a name="l00969"></a>00969 <span class="comment">// that they will also abort the current function on failure.  People</span>
<a name="l00970"></a>00970 <span class="comment">// usually want the fail-fast behavior of FAIL and ASSERT_*, but those</span>
<a name="l00971"></a>00971 <span class="comment">// writing data-driven tests often find themselves using ADD_FAILURE</span>
<a name="l00972"></a>00972 <span class="comment">// and EXPECT_* more.</span>
<a name="l00973"></a>00973 <span class="comment">//</span>
<a name="l00974"></a>00974 <span class="comment">// Examples:</span>
<a name="l00975"></a>00975 <span class="comment">//</span>
<a name="l00976"></a>00976 <span class="comment">//   EXPECT_TRUE(server.StatusIsOK());</span>
<a name="l00977"></a>00977 <span class="comment">//   ASSERT_FALSE(server.HasPendingRequest(port))</span>
<a name="l00978"></a>00978 <span class="comment">//       &lt;&lt; "There are still pending requests " &lt;&lt; "on port " &lt;&lt; port;</span>
<a name="l00979"></a>00979 
<a name="l00980"></a>00980 <span class="comment">// Generates a nonfatal failure with a generic message.</span>
<a name="l00981"></a><a class="code" href="gtest_8h.html#056e7339ae81e48538fae49e20995c60">00981</a> <span class="preprocessor">#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_("Failed")</span>
<a name="l00982"></a>00982 <span class="preprocessor"></span>
<a name="l00983"></a>00983 <span class="comment">// Generates a fatal failure with a generic message.</span>
<a name="l00984"></a><a class="code" href="gtest_8h.html#6585f842dda141356b034c8fa99fe50b">00984</a> <span class="preprocessor">#define FAIL() GTEST_FATAL_FAILURE_("Failed")</span>
<a name="l00985"></a>00985 <span class="preprocessor"></span>
<a name="l00986"></a>00986 <span class="comment">// Generates a success with a generic message.</span>
<a name="l00987"></a><a class="code" href="gtest_8h.html#397afb4cfffe2967500d24102fa8a5ec">00987</a> <span class="preprocessor">#define SUCCEED() GTEST_SUCCESS_("Succeeded")</span>
<a name="l00988"></a>00988 <span class="preprocessor"></span>
<a name="l00989"></a>00989 <span class="comment">// Macros for testing exceptions.</span>
<a name="l00990"></a>00990 <span class="comment">//</span>
<a name="l00991"></a>00991 <span class="comment">//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):</span>
<a name="l00992"></a>00992 <span class="comment">//         Tests that the statement throws the expected exception.</span>
<a name="l00993"></a>00993 <span class="comment">//    * {ASSERT|EXPECT}_NO_THROW(statement):</span>
<a name="l00994"></a>00994 <span class="comment">//         Tests that the statement doesn't throw any exception.</span>
<a name="l00995"></a>00995 <span class="comment">//    * {ASSERT|EXPECT}_ANY_THROW(statement):</span>
<a name="l00996"></a>00996 <span class="comment">//         Tests that the statement throws an exception.</span>
<a name="l00997"></a>00997 
<a name="l00998"></a><a class="code" href="gtest_8h.html#3575afec9214ef9782034ae9305102f5">00998</a> <span class="preprocessor">#define EXPECT_THROW(statement, expected_exception) \</span>
<a name="l00999"></a>00999 <span class="preprocessor">  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01000"></a><a class="code" href="gtest_8h.html#1b299f9d875d6725e27d8cce8c4f1946">01000</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_NO_THROW(statement) \</span>
<a name="l01001"></a>01001 <span class="preprocessor">  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01002"></a><a class="code" href="gtest_8h.html#b5eafb78f18c7f678844c12342f5e0fb">01002</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_ANY_THROW(statement) \</span>
<a name="l01003"></a>01003 <span class="preprocessor">  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01004"></a><a class="code" href="gtest_8h.html#fe452d4e4b830946c36434fb2043cfa2">01004</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_THROW(statement, expected_exception) \</span>
<a name="l01005"></a>01005 <span class="preprocessor">  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)</span>
<a name="l01006"></a><a class="code" href="gtest_8h.html#847284796652b28fae5da442c1525c9a">01006</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_NO_THROW(statement) \</span>
<a name="l01007"></a>01007 <span class="preprocessor">  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)</span>
<a name="l01008"></a><a class="code" href="gtest_8h.html#150089479ffce17438115a50442c56ca">01008</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_ANY_THROW(statement) \</span>
<a name="l01009"></a>01009 <span class="preprocessor">  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)</span>
<a name="l01010"></a>01010 <span class="preprocessor"></span>
<a name="l01011"></a>01011 <span class="comment">// Boolean assertions.</span>
<a name="l01012"></a><a class="code" href="gtest_8h.html#0954fea9252af6aea1df2d8e6e6caa0e">01012</a> <span class="preprocessor">#define EXPECT_TRUE(condition) \</span>
<a name="l01013"></a>01013 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \</span>
<a name="l01014"></a>01014 <span class="preprocessor">                      GTEST_NONFATAL_FAILURE_)</span>
<a name="l01015"></a><a class="code" href="gtest_8h.html#588210b9be54e776cc7901a14a21bd31">01015</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_FALSE(condition) \</span>
<a name="l01016"></a>01016 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \</span>
<a name="l01017"></a>01017 <span class="preprocessor">                      GTEST_NONFATAL_FAILURE_)</span>
<a name="l01018"></a><a class="code" href="gtest_8h.html#bc8edefe2dbf52f5d12542a8e0acc3a3">01018</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_TRUE(condition) \</span>
<a name="l01019"></a>01019 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \</span>
<a name="l01020"></a>01020 <span class="preprocessor">                      GTEST_FATAL_FAILURE_)</span>
<a name="l01021"></a><a class="code" href="gtest_8h.html#9e00bbd67f469acb8893a2ec0a08806d">01021</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_FALSE(condition) \</span>
<a name="l01022"></a>01022 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \</span>
<a name="l01023"></a>01023 <span class="preprocessor">                      GTEST_FATAL_FAILURE_)</span>
<a name="l01024"></a>01024 <span class="preprocessor"></span>
<a name="l01025"></a>01025 <span class="comment">// Includes the auto-generated header that implements a family of</span>
<a name="l01026"></a>01026 <span class="comment">// generic predicate assertion macros.</span>
<a name="l01027"></a>01027 <span class="preprocessor">#include &lt;<a class="code" href="gtest__pred__impl_8h.html">gtest/gtest_pred_impl.h</a>&gt;</span>
<a name="l01028"></a>01028 
<a name="l01029"></a>01029 <span class="comment">// Macros for testing equalities and inequalities.</span>
<a name="l01030"></a>01030 <span class="comment">//</span>
<a name="l01031"></a>01031 <span class="comment">//    * {ASSERT|EXPECT}_EQ(expected, actual): Tests that expected == actual</span>
<a name="l01032"></a>01032 <span class="comment">//    * {ASSERT|EXPECT}_NE(v1, v2):           Tests that v1 != v2</span>
<a name="l01033"></a>01033 <span class="comment">//    * {ASSERT|EXPECT}_LT(v1, v2):           Tests that v1 &lt; v2</span>
<a name="l01034"></a>01034 <span class="comment">//    * {ASSERT|EXPECT}_LE(v1, v2):           Tests that v1 &lt;= v2</span>
<a name="l01035"></a>01035 <span class="comment">//    * {ASSERT|EXPECT}_GT(v1, v2):           Tests that v1 &gt; v2</span>
<a name="l01036"></a>01036 <span class="comment">//    * {ASSERT|EXPECT}_GE(v1, v2):           Tests that v1 &gt;= v2</span>
<a name="l01037"></a>01037 <span class="comment">//</span>
<a name="l01038"></a>01038 <span class="comment">// When they are not, Google Test prints both the tested expressions and</span>
<a name="l01039"></a>01039 <span class="comment">// their actual values.  The values must be compatible built-in types,</span>
<a name="l01040"></a>01040 <span class="comment">// or you will get a compiler error.  By "compatible" we mean that the</span>
<a name="l01041"></a>01041 <span class="comment">// values can be compared by the respective operator.</span>
<a name="l01042"></a>01042 <span class="comment">//</span>
<a name="l01043"></a>01043 <span class="comment">// Note:</span>
<a name="l01044"></a>01044 <span class="comment">//</span>
<a name="l01045"></a>01045 <span class="comment">//   1. It is possible to make a user-defined type work with</span>
<a name="l01046"></a>01046 <span class="comment">//   {ASSERT|EXPECT}_??(), but that requires overloading the</span>
<a name="l01047"></a>01047 <span class="comment">//   comparison operators and is thus discouraged by the Google C++</span>
<a name="l01048"></a>01048 <span class="comment">//   Usage Guide.  Therefore, you are advised to use the</span>
<a name="l01049"></a>01049 <span class="comment">//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are</span>
<a name="l01050"></a>01050 <span class="comment">//   equal.</span>
<a name="l01051"></a>01051 <span class="comment">//</span>
<a name="l01052"></a>01052 <span class="comment">//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on</span>
<a name="l01053"></a>01053 <span class="comment">//   pointers (in particular, C strings).  Therefore, if you use it</span>
<a name="l01054"></a>01054 <span class="comment">//   with two C strings, you are testing how their locations in memory</span>
<a name="l01055"></a>01055 <span class="comment">//   are related, not how their content is related.  To compare two C</span>
<a name="l01056"></a>01056 <span class="comment">//   strings by content, use {ASSERT|EXPECT}_STR*().</span>
<a name="l01057"></a>01057 <span class="comment">//</span>
<a name="l01058"></a>01058 <span class="comment">//   3. {ASSERT|EXPECT}_EQ(expected, actual) is preferred to</span>
<a name="l01059"></a>01059 <span class="comment">//   {ASSERT|EXPECT}_TRUE(expected == actual), as the former tells you</span>
<a name="l01060"></a>01060 <span class="comment">//   what the actual value is when it fails, and similarly for the</span>
<a name="l01061"></a>01061 <span class="comment">//   other comparisons.</span>
<a name="l01062"></a>01062 <span class="comment">//</span>
<a name="l01063"></a>01063 <span class="comment">//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()</span>
<a name="l01064"></a>01064 <span class="comment">//   evaluate their arguments, which is undefined.</span>
<a name="l01065"></a>01065 <span class="comment">//</span>
<a name="l01066"></a>01066 <span class="comment">//   5. These macros evaluate their arguments exactly once.</span>
<a name="l01067"></a>01067 <span class="comment">//</span>
<a name="l01068"></a>01068 <span class="comment">// Examples:</span>
<a name="l01069"></a>01069 <span class="comment">//</span>
<a name="l01070"></a>01070 <span class="comment">//   EXPECT_NE(5, Foo());</span>
<a name="l01071"></a>01071 <span class="comment">//   EXPECT_EQ(NULL, a_pointer);</span>
<a name="l01072"></a>01072 <span class="comment">//   ASSERT_LT(i, array_size);</span>
<a name="l01073"></a>01073 <span class="comment">//   ASSERT_GT(records.size(), 0) &lt;&lt; "There is no record left.";</span>
<a name="l01074"></a>01074 
<a name="l01075"></a><a class="code" href="gtest_8h.html#25e2998b97daf08eafcc1b5abc7dd622">01075</a> <span class="preprocessor">#define EXPECT_EQ(expected, actual) \</span>
<a name="l01076"></a>01076 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal:: \</span>
<a name="l01077"></a>01077 <span class="preprocessor">                      EqHelper&lt;GTEST_IS_NULL_LITERAL_(expected)&gt;::Compare, \</span>
<a name="l01078"></a>01078 <span class="preprocessor">                      expected, actual)</span>
<a name="l01079"></a><a class="code" href="gtest_8h.html#35f03ed1d38bce3c0e3854fe391feca9">01079</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_NE(expected, actual) \</span>
<a name="l01080"></a>01080 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, expected, actual)</span>
<a name="l01081"></a><a class="code" href="gtest_8h.html#b390c93c4955deac6112e6653661a0dd">01081</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_LE(val1, val2) \</span>
<a name="l01082"></a>01082 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)</span>
<a name="l01083"></a><a class="code" href="gtest_8h.html#55bda7934729999a4ab79c534b6c24dc">01083</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_LT(val1, val2) \</span>
<a name="l01084"></a>01084 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)</span>
<a name="l01085"></a><a class="code" href="gtest_8h.html#728dbe0c8d6e93c4e5a192b7296a2ab1">01085</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_GE(val1, val2) \</span>
<a name="l01086"></a>01086 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)</span>
<a name="l01087"></a><a class="code" href="gtest_8h.html#21ab104b356bb282b221b95387cf31eb">01087</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_GT(val1, val2) \</span>
<a name="l01088"></a>01088 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)</span>
<a name="l01089"></a>01089 <span class="preprocessor"></span>
<a name="l01090"></a><a class="code" href="gtest_8h.html#f2f962e2200ec490248e50436826cc60">01090</a> <span class="preprocessor">#define ASSERT_EQ(expected, actual) \</span>
<a name="l01091"></a>01091 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal:: \</span>
<a name="l01092"></a>01092 <span class="preprocessor">                      EqHelper&lt;GTEST_IS_NULL_LITERAL_(expected)&gt;::Compare, \</span>
<a name="l01093"></a>01093 <span class="preprocessor">                      expected, actual)</span>
<a name="l01094"></a><a class="code" href="gtest_8h.html#8a787c812c3e44b173da4f60ad83e869">01094</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_NE(val1, val2) \</span>
<a name="l01095"></a>01095 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)</span>
<a name="l01096"></a><a class="code" href="gtest_8h.html#3e6b1f3aa6de97af096edf1a32e45bb2">01096</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_LE(val1, val2) \</span>
<a name="l01097"></a>01097 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)</span>
<a name="l01098"></a><a class="code" href="gtest_8h.html#eeb3d8146f648fc6be63b975a9e243bd">01098</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_LT(val1, val2) \</span>
<a name="l01099"></a>01099 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)</span>
<a name="l01100"></a><a class="code" href="gtest_8h.html#83affb552bff41687f6a6631acd5e2ca">01100</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_GE(val1, val2) \</span>
<a name="l01101"></a>01101 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)</span>
<a name="l01102"></a><a class="code" href="gtest_8h.html#f2f5a56962986487f93b14f99db48e91">01102</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_GT(val1, val2) \</span>
<a name="l01103"></a>01103 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)</span>
<a name="l01104"></a>01104 <span class="preprocessor"></span>
<a name="l01105"></a>01105 <span class="comment">// C String Comparisons.  All tests treat NULL and any non-NULL string</span>
<a name="l01106"></a>01106 <span class="comment">// as different.  Two NULLs are equal.</span>
<a name="l01107"></a>01107 <span class="comment">//</span>
<a name="l01108"></a>01108 <span class="comment">//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2</span>
<a name="l01109"></a>01109 <span class="comment">//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2</span>
<a name="l01110"></a>01110 <span class="comment">//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case</span>
<a name="l01111"></a>01111 <span class="comment">//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case</span>
<a name="l01112"></a>01112 <span class="comment">//</span>
<a name="l01113"></a>01113 <span class="comment">// For wide or narrow string objects, you can use the</span>
<a name="l01114"></a>01114 <span class="comment">// {ASSERT|EXPECT}_??() macros.</span>
<a name="l01115"></a>01115 <span class="comment">//</span>
<a name="l01116"></a>01116 <span class="comment">// Don't depend on the order in which the arguments are evaluated,</span>
<a name="l01117"></a>01117 <span class="comment">// which is undefined.</span>
<a name="l01118"></a>01118 <span class="comment">//</span>
<a name="l01119"></a>01119 <span class="comment">// These macros evaluate their arguments exactly once.</span>
<a name="l01120"></a>01120 
<a name="l01121"></a><a class="code" href="gtest_8h.html#0876b77880bfd56fe012815bc4ff9ed5">01121</a> <span class="preprocessor">#define EXPECT_STREQ(expected, actual) \</span>
<a name="l01122"></a>01122 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, expected, actual)</span>
<a name="l01123"></a><a class="code" href="gtest_8h.html#647e43522cc2175b566ba531b461a0b5">01123</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_STRNE(s1, s2) \</span>
<a name="l01124"></a>01124 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)</span>
<a name="l01125"></a><a class="code" href="gtest_8h.html#9fa7428fad648293f15d8d59558c6d15">01125</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_STRCASEEQ(expected, actual) \</span>
<a name="l01126"></a>01126 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, expected, actual)</span>
<a name="l01127"></a><a class="code" href="gtest_8h.html#aeea193c70fcfc82b0c83c3dc51307dd">01127</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_STRCASENE(s1, s2)\</span>
<a name="l01128"></a>01128 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)</span>
<a name="l01129"></a>01129 <span class="preprocessor"></span>
<a name="l01130"></a><a class="code" href="gtest_8h.html#089f4a9f6397a8d03717b07c4ccf2704">01130</a> <span class="preprocessor">#define ASSERT_STREQ(expected, actual) \</span>
<a name="l01131"></a>01131 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, expected, actual)</span>
<a name="l01132"></a><a class="code" href="gtest_8h.html#bd0f5611645bebac41d8f9f5434dfa89">01132</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_STRNE(s1, s2) \</span>
<a name="l01133"></a>01133 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)</span>
<a name="l01134"></a><a class="code" href="gtest_8h.html#a5730f5d00d9fc0cc84ad1ed7a221beb">01134</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_STRCASEEQ(expected, actual) \</span>
<a name="l01135"></a>01135 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, expected, actual)</span>
<a name="l01136"></a><a class="code" href="gtest_8h.html#90d237b56ead141b6a1f194d2500a129">01136</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_STRCASENE(s1, s2)\</span>
<a name="l01137"></a>01137 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)</span>
<a name="l01138"></a>01138 <span class="preprocessor"></span>
<a name="l01139"></a>01139 <span class="comment">// Macros for comparing floating-point numbers.</span>
<a name="l01140"></a>01140 <span class="comment">//</span>
<a name="l01141"></a>01141 <span class="comment">//    * {ASSERT|EXPECT}_FLOAT_EQ(expected, actual):</span>
<a name="l01142"></a>01142 <span class="comment">//         Tests that two float values are almost equal.</span>
<a name="l01143"></a>01143 <span class="comment">//    * {ASSERT|EXPECT}_DOUBLE_EQ(expected, actual):</span>
<a name="l01144"></a>01144 <span class="comment">//         Tests that two double values are almost equal.</span>
<a name="l01145"></a>01145 <span class="comment">//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):</span>
<a name="l01146"></a>01146 <span class="comment">//         Tests that v1 and v2 are within the given distance to each other.</span>
<a name="l01147"></a>01147 <span class="comment">//</span>
<a name="l01148"></a>01148 <span class="comment">// Google Test uses ULP-based comparison to automatically pick a default</span>
<a name="l01149"></a>01149 <span class="comment">// error bound that is appropriate for the operands.  See the</span>
<a name="l01150"></a>01150 <span class="comment">// FloatingPoint template class in gtest-internal.h if you are</span>
<a name="l01151"></a>01151 <span class="comment">// interested in the implementation details.</span>
<a name="l01152"></a>01152 
<a name="l01153"></a><a class="code" href="gtest_8h.html#e1c0b7434cf078fda15a96eadea0dc68">01153</a> <span class="preprocessor">#define EXPECT_FLOAT_EQ(expected, actual)\</span>
<a name="l01154"></a>01154 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \</span>
<a name="l01155"></a>01155 <span class="preprocessor">                      expected, actual)</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span>
<a name="l01157"></a><a class="code" href="gtest_8h.html#1341fe299076bdac4e9a04d7f42f7e79">01157</a> <span class="preprocessor">#define EXPECT_DOUBLE_EQ(expected, actual)\</span>
<a name="l01158"></a>01158 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \</span>
<a name="l01159"></a>01159 <span class="preprocessor">                      expected, actual)</span>
<a name="l01160"></a>01160 <span class="preprocessor"></span>
<a name="l01161"></a><a class="code" href="gtest_8h.html#b595d36cf2b1e35ce5a3035432b0ba9c">01161</a> <span class="preprocessor">#define ASSERT_FLOAT_EQ(expected, actual)\</span>
<a name="l01162"></a>01162 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \</span>
<a name="l01163"></a>01163 <span class="preprocessor">                      expected, actual)</span>
<a name="l01164"></a>01164 <span class="preprocessor"></span>
<a name="l01165"></a><a class="code" href="gtest_8h.html#83dda6fa372bc1f88db2f29a00de147a">01165</a> <span class="preprocessor">#define ASSERT_DOUBLE_EQ(expected, actual)\</span>
<a name="l01166"></a>01166 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \</span>
<a name="l01167"></a>01167 <span class="preprocessor">                      expected, actual)</span>
<a name="l01168"></a>01168 <span class="preprocessor"></span>
<a name="l01169"></a><a class="code" href="gtest_8h.html#29bed5ba2dfd25740dfecc27eaaaa6e2">01169</a> <span class="preprocessor">#define EXPECT_NEAR(val1, val2, abs_error)\</span>
<a name="l01170"></a>01170 <span class="preprocessor">  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \</span>
<a name="l01171"></a>01171 <span class="preprocessor">                      val1, val2, abs_error)</span>
<a name="l01172"></a>01172 <span class="preprocessor"></span>
<a name="l01173"></a><a class="code" href="gtest_8h.html#e50b7af8705487a5ce950fa9851ac760">01173</a> <span class="preprocessor">#define ASSERT_NEAR(val1, val2, abs_error)\</span>
<a name="l01174"></a>01174 <span class="preprocessor">  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \</span>
<a name="l01175"></a>01175 <span class="preprocessor">                      val1, val2, abs_error)</span>
<a name="l01176"></a>01176 <span class="preprocessor"></span>
<a name="l01177"></a>01177 <span class="comment">// These predicate format functions work on floating-point values, and</span>
<a name="l01178"></a>01178 <span class="comment">// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.</span>
<a name="l01179"></a>01179 <span class="comment">//</span>
<a name="l01180"></a>01180 <span class="comment">//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);</span>
<a name="l01181"></a>01181 
<a name="l01182"></a>01182 <span class="comment">// Asserts that val1 is less than, or almost equal to, val2.  Fails</span>
<a name="l01183"></a>01183 <span class="comment">// otherwise.  In particular, it fails if either val1 or val2 is NaN.</span>
<a name="l01184"></a>01184 AssertionResult <a class="code" href="namespacetesting.html#8df0239796a2652f170dd5237e5a04dc">FloatLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01185"></a>01185                         <span class="keywordtype">float</span> val1, <span class="keywordtype">float</span> val2);
<a name="l01186"></a>01186 AssertionResult <a class="code" href="namespacetesting.html#55e89dc0f65ab5a155ffdf06e6eac327">DoubleLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01187"></a>01187                          <span class="keywordtype">double</span> val1, <span class="keywordtype">double</span> val2);
<a name="l01188"></a>01188 
<a name="l01189"></a>01189 
<a name="l01190"></a>01190 <span class="preprocessor">#ifdef GTEST_OS_WINDOWS</span>
<a name="l01191"></a>01191 <span class="preprocessor"></span>
<a name="l01192"></a>01192 <span class="comment">// Macros that test for HRESULT failure and success, these are only useful</span>
<a name="l01193"></a>01193 <span class="comment">// on Windows, and rely on Windows SDK macros and APIs to compile.</span>
<a name="l01194"></a>01194 <span class="comment">//</span>
<a name="l01195"></a>01195 <span class="comment">//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)</span>
<a name="l01196"></a>01196 <span class="comment">//</span>
<a name="l01197"></a>01197 <span class="comment">// When expr unexpectedly fails or succeeds, Google Test prints the</span>
<a name="l01198"></a>01198 <span class="comment">// expected result and the actual result with both a human-readable</span>
<a name="l01199"></a>01199 <span class="comment">// string representation of the error, if available, as well as the</span>
<a name="l01200"></a>01200 <span class="comment">// hex result code.</span>
<a name="l01201"></a>01201 <span class="preprocessor">#define EXPECT_HRESULT_SUCCEEDED(expr) \</span>
<a name="l01202"></a>01202 <span class="preprocessor">    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))</span>
<a name="l01203"></a>01203 <span class="preprocessor"></span>
<a name="l01204"></a>01204 <span class="preprocessor">#define ASSERT_HRESULT_SUCCEEDED(expr) \</span>
<a name="l01205"></a>01205 <span class="preprocessor">    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))</span>
<a name="l01206"></a>01206 <span class="preprocessor"></span>
<a name="l01207"></a>01207 <span class="preprocessor">#define EXPECT_HRESULT_FAILED(expr) \</span>
<a name="l01208"></a>01208 <span class="preprocessor">    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))</span>
<a name="l01209"></a>01209 <span class="preprocessor"></span>
<a name="l01210"></a>01210 <span class="preprocessor">#define ASSERT_HRESULT_FAILED(expr) \</span>
<a name="l01211"></a>01211 <span class="preprocessor">    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))</span>
<a name="l01212"></a>01212 <span class="preprocessor"></span>
<a name="l01213"></a>01213 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l01214"></a>01214 <span class="preprocessor"></span>
<a name="l01215"></a>01215 <span class="comment">// Macros that execute statement and check that it doesn't generate new fatal</span>
<a name="l01216"></a>01216 <span class="comment">// failures in the current thread.</span>
<a name="l01217"></a>01217 <span class="comment">//</span>
<a name="l01218"></a>01218 <span class="comment">//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);</span>
<a name="l01219"></a>01219 <span class="comment">//</span>
<a name="l01220"></a>01220 <span class="comment">// Examples:</span>
<a name="l01221"></a>01221 <span class="comment">//</span>
<a name="l01222"></a>01222 <span class="comment">//   EXPECT_NO_FATAL_FAILURE(Process());</span>
<a name="l01223"></a>01223 <span class="comment">//   ASSERT_NO_FATAL_FAILURE(Process()) &lt;&lt; "Process() failed";</span>
<a name="l01224"></a>01224 <span class="comment">//</span>
<a name="l01225"></a><a class="code" href="gtest_8h.html#b957ba33b4f4c2b1418ae88fc659982f">01225</a> <span class="preprocessor">#define ASSERT_NO_FATAL_FAILURE(statement) \</span>
<a name="l01226"></a>01226 <span class="preprocessor">    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)</span>
<a name="l01227"></a><a class="code" href="gtest_8h.html#72b583d5983c08d7126b36ca5e59be23">01227</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_NO_FATAL_FAILURE(statement) \</span>
<a name="l01228"></a>01228 <span class="preprocessor">    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01229"></a>01229 <span class="preprocessor"></span>
<a name="l01230"></a>01230 <span class="comment">// Causes a trace (including the source file path, the current line</span>
<a name="l01231"></a>01231 <span class="comment">// number, and the given message) to be included in every test failure</span>
<a name="l01232"></a>01232 <span class="comment">// message generated by code in the current scope.  The effect is</span>
<a name="l01233"></a>01233 <span class="comment">// undone when the control leaves the current scope.</span>
<a name="l01234"></a>01234 <span class="comment">//</span>
<a name="l01235"></a>01235 <span class="comment">// The message argument can be anything streamable to std::ostream.</span>
<a name="l01236"></a>01236 <span class="comment">//</span>
<a name="l01237"></a>01237 <span class="comment">// In the implementation, we include the current line number as part</span>
<a name="l01238"></a>01238 <span class="comment">// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s</span>
<a name="l01239"></a>01239 <span class="comment">// to appear in the same block - as long as they are on different</span>
<a name="l01240"></a>01240 <span class="comment">// lines.</span>
<a name="l01241"></a><a class="code" href="gtest_8h.html#03d8a92d5a8cf13e60510636300807b2">01241</a> <span class="preprocessor">#define SCOPED_TRACE(message) \</span>
<a name="l01242"></a>01242 <span class="preprocessor">  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\</span>
<a name="l01243"></a>01243 <span class="preprocessor">    __FILE__, __LINE__, ::testing::Message() &lt;&lt; (message))</span>
<a name="l01244"></a>01244 <span class="preprocessor"></span>
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="comment">// Defines a test.</span>
<a name="l01247"></a>01247 <span class="comment">//</span>
<a name="l01248"></a>01248 <span class="comment">// The first parameter is the name of the test case, and the second</span>
<a name="l01249"></a>01249 <span class="comment">// parameter is the name of the test within the test case.</span>
<a name="l01250"></a>01250 <span class="comment">//</span>
<a name="l01251"></a>01251 <span class="comment">// The convention is to end the test case name with "Test".  For</span>
<a name="l01252"></a>01252 <span class="comment">// example, a test case for the Foo class can be named FooTest.</span>
<a name="l01253"></a>01253 <span class="comment">//</span>
<a name="l01254"></a>01254 <span class="comment">// The user should put his test code between braces after using this</span>
<a name="l01255"></a>01255 <span class="comment">// macro.  Example:</span>
<a name="l01256"></a>01256 <span class="comment">//</span>
<a name="l01257"></a>01257 <span class="comment">//   TEST(FooTest, InitializesCorrectly) {</span>
<a name="l01258"></a>01258 <span class="comment">//     Foo foo;</span>
<a name="l01259"></a>01259 <span class="comment">//     EXPECT_TRUE(foo.StatusIsOK());</span>
<a name="l01260"></a>01260 <span class="comment">//   }</span>
<a name="l01261"></a>01261 
<a name="l01262"></a>01262 <span class="comment">// Note that we call GetTestTypeId() instead of GetTypeId&lt;</span>
<a name="l01263"></a>01263 <span class="comment">// ::testing::Test&gt;() here to get the type ID of testing::Test.  This</span>
<a name="l01264"></a>01264 <span class="comment">// is to work around a suspected linker bug when using Google Test as</span>
<a name="l01265"></a>01265 <span class="comment">// a framework on Mac OS X.  The bug causes GetTypeId&lt;</span>
<a name="l01266"></a>01266 <span class="comment">// ::testing::Test&gt;() to return different values depending on whether</span>
<a name="l01267"></a>01267 <span class="comment">// the call is from the Google Test framework itself or from user test</span>
<a name="l01268"></a>01268 <span class="comment">// code.  GetTestTypeId() is guaranteed to always return the same</span>
<a name="l01269"></a>01269 <span class="comment">// value, as it always calls GetTypeId&lt;&gt;() from the Google Test</span>
<a name="l01270"></a>01270 <span class="comment">// framework.</span>
<a name="l01271"></a><a class="code" href="gtest_8h.html#598efb903152a27abbe3562ea890d1b9">01271</a> <span class="preprocessor">#define TEST(test_case_name, test_name)\</span>
<a name="l01272"></a>01272 <span class="preprocessor">  GTEST_TEST_(test_case_name, test_name,\</span>
<a name="l01273"></a>01273 <span class="preprocessor">              ::testing::Test, ::testing::internal::GetTestTypeId())</span>
<a name="l01274"></a>01274 <span class="preprocessor"></span>
<a name="l01275"></a>01275 
<a name="l01276"></a>01276 <span class="comment">// Defines a test that uses a test fixture.</span>
<a name="l01277"></a>01277 <span class="comment">//</span>
<a name="l01278"></a>01278 <span class="comment">// The first parameter is the name of the test fixture class, which</span>
<a name="l01279"></a>01279 <span class="comment">// also doubles as the test case name.  The second parameter is the</span>
<a name="l01280"></a>01280 <span class="comment">// name of the test within the test case.</span>
<a name="l01281"></a>01281 <span class="comment">//</span>
<a name="l01282"></a>01282 <span class="comment">// A test fixture class must be declared earlier.  The user should put</span>
<a name="l01283"></a>01283 <span class="comment">// his test code between braces after using this macro.  Example:</span>
<a name="l01284"></a>01284 <span class="comment">//</span>
<a name="l01285"></a>01285 <span class="comment">//   class FooTest : public testing::Test {</span>
<a name="l01286"></a>01286 <span class="comment">//    protected:</span>
<a name="l01287"></a>01287 <span class="comment">//     virtual void SetUp() { b_.AddElement(3); }</span>
<a name="l01288"></a>01288 <span class="comment">//</span>
<a name="l01289"></a>01289 <span class="comment">//     Foo a_;</span>
<a name="l01290"></a>01290 <span class="comment">//     Foo b_;</span>
<a name="l01291"></a>01291 <span class="comment">//   };</span>
<a name="l01292"></a>01292 <span class="comment">//</span>
<a name="l01293"></a>01293 <span class="comment">//   TEST_F(FooTest, InitializesCorrectly) {</span>
<a name="l01294"></a>01294 <span class="comment">//     EXPECT_TRUE(a_.StatusIsOK());</span>
<a name="l01295"></a>01295 <span class="comment">//   }</span>
<a name="l01296"></a>01296 <span class="comment">//</span>
<a name="l01297"></a>01297 <span class="comment">//   TEST_F(FooTest, ReturnsElementCountCorrectly) {</span>
<a name="l01298"></a>01298 <span class="comment">//     EXPECT_EQ(0, a_.size());</span>
<a name="l01299"></a>01299 <span class="comment">//     EXPECT_EQ(1, b_.size());</span>
<a name="l01300"></a>01300 <span class="comment">//   }</span>
<a name="l01301"></a>01301 
<a name="l01302"></a><a class="code" href="gtest_8h.html#65252d195eb5c09683b70370e9447b2f">01302</a> <span class="preprocessor">#define TEST_F(test_fixture, test_name)\</span>
<a name="l01303"></a>01303 <span class="preprocessor">  GTEST_TEST_(test_fixture, test_name, test_fixture,\</span>
<a name="l01304"></a>01304 <span class="preprocessor">              ::testing::internal::GetTypeId&lt;test_fixture&gt;())</span>
<a name="l01305"></a>01305 <span class="preprocessor"></span>
<a name="l01306"></a>01306 <span class="comment">// Use this macro in main() to run all tests.  It returns 0 if all</span>
<a name="l01307"></a>01307 <span class="comment">// tests are successful, or 1 otherwise.</span>
<a name="l01308"></a>01308 <span class="comment">//</span>
<a name="l01309"></a>01309 <span class="comment">// RUN_ALL_TESTS() should be invoked after the command line has been</span>
<a name="l01310"></a>01310 <span class="comment">// parsed by InitGoogleTest().</span>
<a name="l01311"></a>01311 
<a name="l01312"></a><a class="code" href="gtest_8h.html#e5b480275b42e3957841ee3e7acf6dbc">01312</a> <span class="preprocessor">#define RUN_ALL_TESTS()\</span>
<a name="l01313"></a>01313 <span class="preprocessor">  (::testing::UnitTest::GetInstance()-&gt;Run())</span>
<a name="l01314"></a>01314 <span class="preprocessor"></span>
<a name="l01315"></a>01315 }  <span class="comment">// namespace testing</span>
<a name="l01316"></a>01316 
<a name="l01317"></a>01317 <span class="preprocessor">#endif  // GTEST_INCLUDE_GTEST_GTEST_H_</span>
</pre></div><hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 9 00:05:41 2009 for EC3 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.2 </small></address>
</body>
</html>
